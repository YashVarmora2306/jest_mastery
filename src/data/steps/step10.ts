import { Step } from '../types';

export const step10: Step = {
  "id": "10",
  "title": "Best Practices & Real-World E-Commerce Project",
  "initialCode": "// ============================================\r\n// STEP 10: Best Practices & Real-World Project\r\n// ============================================\r\n\r\n// ============================================\r\n// REAL-WORLD E-COMMERCE SYSTEM\r\n// ============================================\r\n\r\n// ================== MODELS ==================\r\n\r\nclass Product {\r\n  constructor(id, name, price, stock, category) {\r\n    this.id = id;\r\n    this.name = name;\r\n    this.price = price;\r\n    this.stock = stock;\r\n    this.category = category;\r\n  }\r\n  \r\n  isAvailable() {\r\n    return this.stock > 0;\r\n  }\r\n  \r\n  reduceStock(quantity) {\r\n    if (quantity > this.stock) {\r\n      throw new Error('Insufficient stock');\r\n    }\r\n    this.stock -= quantity;\r\n  }\r\n  \r\n  increaseStock(quantity) {\r\n    this.stock += quantity;\r\n  }\r\n}\r\n\r\nclass CartItem {\r\n  constructor(product, quantity) {\r\n    if (!product) {\r\n      throw new Error('Product is required');\r\n    }\r\n    if (quantity <= 0) {\r\n      throw new Error('Quantity must be positive');\r\n    }\r\n    this.product = product;\r\n    this.quantity = quantity;\r\n  }\r\n  \r\n  getSubtotal() {\r\n    return this.product.price * this.quantity;\r\n  }\r\n  \r\n  increaseQuantity(amount = 1) {\r\n    this.quantity += amount;\r\n  }\r\n  \r\n  decreaseQuantity(amount = 1) {\r\n    this.quantity = Math.max(0, this.quantity - amount);\r\n    return this.quantity;\r\n  }\r\n}\r\n\r\nclass ShoppingCart {\r\n  constructor(userId) {\r\n    this.userId = userId;\r\n    this.items = [];\r\n    this.discountCode = null;\r\n  }\r\n  \r\n  addItem(product, quantity = 1) {\r\n    if (!product.isAvailable()) {\r\n      throw new Error('Product is out of stock');\r\n    }\r\n    \r\n    const existingItem = this.items.find(item => item.product.id === product.id);\r\n    \r\n    if (existingItem) {\r\n      existingItem.increaseQuantity(quantity);\r\n    } else {\r\n      this.items.push(new CartItem(product, quantity));\r\n    }\r\n  }\r\n  \r\n  removeItem(productId) {\r\n    const index = this.items.findIndex(item => item.product.id === productId);\r\n    if (index === -1) {\r\n      throw new Error('Item not found in cart');\r\n    }\r\n    this.items.splice(index, 1);\r\n  }\r\n  \r\n  updateQuantity(productId, quantity) {\r\n    const item = this.items.find(item => item.product.id === productId);\r\n    if (!item) {\r\n      throw new Error('Item not found in cart');\r\n    }\r\n    if (quantity <= 0) {\r\n      this.removeItem(productId);\r\n    } else {\r\n      item.quantity = quantity;\r\n    }\r\n  }\r\n  \r\n  applyDiscount(code) {\r\n    const validCodes = {\r\n      'SAVE10': 0.10,\r\n      'SAVE20': 0.20,\r\n      'WELCOME': 0.15\r\n    };\r\n    \r\n    if (!validCodes[code]) {\r\n      throw new Error('Invalid discount code');\r\n    }\r\n    \r\n    this.discountCode = code;\r\n    return validCodes[code];\r\n  }\r\n  \r\n  getSubtotal() {\r\n    return this.items.reduce((sum, item) => sum + item.getSubtotal(), 0);\r\n  }\r\n  \r\n  getDiscount() {\r\n    if (!this.discountCode) return 0;\r\n    \r\n    const discountRates = {\r\n      'SAVE10': 0.10,\r\n      'SAVE20': 0.20,\r\n      'WELCOME': 0.15\r\n    };\r\n    \r\n    return this.getSubtotal() * (discountRates[this.discountCode] || 0);\r\n  }\r\n  \r\n  getShipping() {\r\n    const subtotal = this.getSubtotal();\r\n    if (subtotal >= 100) return 0;\r\n    if (subtotal >= 50) return 5;\r\n    return 10;\r\n  }\r\n  \r\n  getTotal() {\r\n    return this.getSubtotal() - this.getDiscount() + this.getShipping();\r\n  }\r\n  \r\n  clear() {\r\n    this.items = [];\r\n    this.discountCode = null;\r\n  }\r\n  \r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n  \r\n  getItemCount() {\r\n    return this.items.reduce((sum, item) => sum + item.quantity, 0);\r\n  }\r\n}\r\n\r\nclass Order {\r\n  constructor(id, userId, items, total) {\r\n    this.id = id;\r\n    this.userId = userId;\r\n    this.items = items;\r\n    this.total = total;\r\n    this.status = 'pending';\r\n    this.createdAt = new Date();\r\n  }\r\n  \r\n  confirm() {\r\n    if (this.status !== 'pending') {\r\n      throw new Error('Order can only be confirmed when pending');\r\n    }\r\n    this.status = 'confirmed';\r\n  }\r\n  \r\n  ship() {\r\n    if (this.status !== 'confirmed') {\r\n      throw new Error('Order must be confirmed before shipping');\r\n    }\r\n    this.status = 'shipped';\r\n  }\r\n  \r\n  deliver() {\r\n    if (this.status !== 'shipped') {\r\n      throw new Error('Order must be shipped before delivery');\r\n    }\r\n    this.status = 'delivered';\r\n  }\r\n  \r\n  cancel() {\r\n    if (this.status === 'delivered') {\r\n      throw new Error('Cannot cancel delivered order');\r\n    }\r\n    this.status = 'cancelled';\r\n  }\r\n}\r\n\r\n// ================== SERVICES ==================\r\n\r\nclass OrderService {\r\n  constructor(paymentService) {\r\n    this.paymentService = paymentService;\r\n    this.orders = [];\r\n    this.nextOrderId = 1;\r\n  }\r\n  \r\n  async createOrder(cart, paymentMethod) {\r\n    if (cart.isEmpty()) {\r\n      throw new Error('Cannot create order from empty cart');\r\n    }\r\n    \r\n    // Process payment\r\n    const paymentResult = await this.paymentService.processPayment(\r\n      cart.getTotal(),\r\n      paymentMethod\r\n    );\r\n    \r\n    if (!paymentResult.success) {\r\n      throw new Error('Payment failed');\r\n    }\r\n    \r\n    // Create order\r\n    const order = new Order(\r\n      this.nextOrderId++,\r\n      cart.userId,\r\n      [...cart.items],\r\n      cart.getTotal()\r\n    );\r\n    \r\n    this.orders.push(order);\r\n    \r\n    // Reduce stock\r\n    for (const item of cart.items) {\r\n      item.product.reduceStock(item.quantity);\r\n    }\r\n    \r\n    // Clear cart\r\n    cart.clear();\r\n    \r\n    return order;\r\n  }\r\n  \r\n  getOrder(orderId) {\r\n    return this.orders.find(order => order.id === orderId) || null;\r\n  }\r\n  \r\n  getUserOrders(userId) {\r\n    return this.orders.filter(order => order.userId === userId);\r\n  }\r\n  \r\n  cancelOrder(orderId) {\r\n    const order = this.getOrder(orderId);\r\n    if (!order) {\r\n      throw new Error('Order not found');\r\n    }\r\n    \r\n    order.cancel();\r\n    \r\n    // Restore stock\r\n    for (const item of order.items) {\r\n      item.product.increaseStock(item.quantity);\r\n    }\r\n    \r\n    return order;\r\n  }\r\n}\r\n\r\n// ================== TEST UTILITIES ==================\r\n\r\n// Builder Pattern for Test Data\r\nclass ProductBuilder {\r\n  constructor() {\r\n    this.product = {\r\n      id: 1,\r\n      name: 'Test Product',\r\n      price: 10,\r\n      stock: 100,\r\n      category: 'general'\r\n    };\r\n  }\r\n  \r\n  withId(id) {\r\n    this.product.id = id;\r\n    return this;\r\n  }\r\n  \r\n  withName(name) {\r\n    this.product.name = name;\r\n    return this;\r\n  }\r\n  \r\n  withPrice(price) {\r\n    this.product.price = price;\r\n    return this;\r\n  }\r\n  \r\n  withStock(stock) {\r\n    this.product.stock = stock;\r\n    return this;\r\n  }\r\n  \r\n  withCategory(category) {\r\n    this.product.category = category;\r\n    return this;\r\n  }\r\n  \r\n  outOfStock() {\r\n    this.product.stock = 0;\r\n    return this;\r\n  }\r\n  \r\n  build() {\r\n    return new Product(\r\n      this.product.id,\r\n      this.product.name,\r\n      this.product.price,\r\n      this.product.stock,\r\n      this.product.category\r\n    );\r\n  }\r\n}\r\n\r\n// Custom Matchers\r\nexpect.extend({\r\n  toBeInRange(received, min, max) {\r\n    const pass = received >= min && received <= max;\r\n    return {\r\n      pass,\r\n      message: () => \r\n        pass\r\n          ? `expected \\${received} not to be within range \\${min}-\\${max}`\r\n          : `expected \\${received} to be within range \\${min}-\\${max}, but got \\${received}`\r\n    };\r\n  },\r\n  \r\n  toHaveStock(product, expectedStock) {\r\n    const pass = product.stock === expectedStock;\r\n    return {\r\n      pass,\r\n      message: () => \r\n        `expected product to have stock \\${expectedStock}, but got \\${product.stock}`\r\n    };\r\n  }\r\n});\r\n\r\n// ============================================\r\n// COMPREHENSIVE TEST SUITE\r\n// ============================================\r\n\r\ndescribe('E-Commerce System', () => {\r\n  \r\n  // ================== PRODUCT TESTS ==================\r\n  \r\n  describe('Product', () => {\r\n    let product;\r\n    \r\n    beforeEach(() => {\r\n      product = new ProductBuilder()\r\n        .withName('Laptop')\r\n        .withPrice(1000)\r\n        .withStock(10)\r\n        .build();\r\n    });\r\n    \r\n    describe('isAvailable()', () => {\r\n      test('returns true when stock is available', () => {\r\n        expect(product.isAvailable()).toBe(true);\r\n      });\r\n      \r\n      test('returns false when out of stock', () => {\r\n        const outOfStock = new ProductBuilder().outOfStock().build();\r\n        expect(outOfStock.isAvailable()).toBe(false);\r\n      });\r\n    });\r\n    \r\n    describe('reduceStock()', () => {\r\n      test('reduces stock by specified quantity', () => {\r\n        product.reduceStock(3);\r\n        expect(product.stock).toBe(7);\r\n      });\r\n      \r\n      test('throws error when quantity exceeds stock', () => {\r\n        expect(() => product.reduceStock(11)).toThrow('Insufficient stock');\r\n      });\r\n      \r\n      test('can reduce stock to zero', () => {\r\n        product.reduceStock(10);\r\n        expect(product.stock).toBe(0);\r\n      });\r\n    });\r\n    \r\n    describe('increaseStock()', () => {\r\n      test('increases stock by specified quantity', () => {\r\n        product.increaseStock(5);\r\n        expect(product.stock).toBe(15);\r\n      });\r\n    });\r\n  });\r\n  \r\n  // ================== CART ITEM TESTS ==================\r\n  \r\n  describe('CartItem', () => {\r\n    let product;\r\n    \r\n    beforeEach(() => {\r\n      product = new ProductBuilder().withPrice(50).build();\r\n    });\r\n    \r\n    describe('constructor', () => {\r\n      test('creates cart item with product and quantity', () => {\r\n        const item = new CartItem(product, 2);\r\n        expect(item.product).toBe(product);\r\n        expect(item.quantity).toBe(2);\r\n      });\r\n      \r\n      test('throws error when product is null', () => {\r\n        expect(() => new CartItem(null, 1)).toThrow('Product is required');\r\n      });\r\n      \r\n      test('throws error when quantity is zero', () => {\r\n        expect(() => new CartItem(product, 0)).toThrow('Quantity must be positive');\r\n      });\r\n      \r\n      test('throws error when quantity is negative', () => {\r\n        expect(() => new CartItem(product, -1)).toThrow('Quantity must be positive');\r\n      });\r\n    });\r\n    \r\n    describe('getSubtotal()', () => {\r\n      test('calculates subtotal correctly', () => {\r\n        const item = new CartItem(product, 3);\r\n        expect(item.getSubtotal()).toBe(150); // 50 * 3\r\n      });\r\n    });\r\n    \r\n    describe('quantity management', () => {\r\n      test('increases quantity', () => {\r\n        const item = new CartItem(product, 1);\r\n        item.increaseQuantity(2);\r\n        expect(item.quantity).toBe(3);\r\n      });\r\n      \r\n      test('decreases quantity', () => {\r\n        const item = new CartItem(product, 5);\r\n        item.decreaseQuantity(2);\r\n        expect(item.quantity).toBe(3);\r\n      });\r\n      \r\n      test('cannot decrease quantity below zero', () => {\r\n        const item = new CartItem(product, 2);\r\n        item.decreaseQuantity(5);\r\n        expect(item.quantity).toBe(0);\r\n      });\r\n    });\r\n  });\r\n  \r\n  // ================== SHOPPING CART TESTS ==================\r\n  \r\n  describe('ShoppingCart', () => {\r\n    let cart;\r\n    let product1, product2;\r\n    \r\n    beforeEach(() => {\r\n      cart = new ShoppingCart('user-123');\r\n      product1 = new ProductBuilder()\r\n        .withId(1)\r\n        .withName('Product 1')\r\n        .withPrice(10)\r\n        .build();\r\n      product2 = new ProductBuilder()\r\n        .withId(2)\r\n        .withName('Product 2')\r\n        .withPrice(20)\r\n        .build();\r\n    });\r\n    \r\n    describe('addItem()', () => {\r\n      test('adds new item to cart', () => {\r\n        cart.addItem(product1, 2);\r\n        \r\n        expect(cart.items).toHaveLength(1);\r\n        expect(cart.items[0].product).toBe(product1);\r\n        expect(cart.items[0].quantity).toBe(2);\r\n      });\r\n      \r\n      test('increases quantity for existing item', () => {\r\n        cart.addItem(product1, 2);\r\n        cart.addItem(product1, 3);\r\n        \r\n        expect(cart.items).toHaveLength(1);\r\n        expect(cart.items[0].quantity).toBe(5);\r\n      });\r\n      \r\n      test('throws error when product is out of stock', () => {\r\n        const outOfStock = new ProductBuilder().outOfStock().build();\r\n        \r\n        expect(() => cart.addItem(outOfStock)).toThrow('Product is out of stock');\r\n      });\r\n      \r\n      test('adds multiple different products', () => {\r\n        cart.addItem(product1, 1);\r\n        cart.addItem(product2, 1);\r\n        \r\n        expect(cart.items).toHaveLength(2);\r\n      });\r\n    });\r\n    \r\n    describe('removeItem()', () => {\r\n      test('removes item from cart', () => {\r\n        cart.addItem(product1, 1);\r\n        cart.removeItem(product1.id);\r\n        \r\n        expect(cart.items).toHaveLength(0);\r\n      });\r\n      \r\n      test('throws error when item not found', () => {\r\n        expect(() => cart.removeItem(999)).toThrow('Item not found in cart');\r\n      });\r\n      \r\n      test('removes correct item from multiple items', () => {\r\n        cart.addItem(product1, 1);\r\n        cart.addItem(product2, 1);\r\n        cart.removeItem(product1.id);\r\n        \r\n        expect(cart.items).toHaveLength(1);\r\n        expect(cart.items[0].product.id).toBe(product2.id);\r\n      });\r\n    });\r\n    \r\n    describe('updateQuantity()', () => {\r\n      beforeEach(() => {\r\n        cart.addItem(product1, 5);\r\n      });\r\n      \r\n      test('updates item quantity', () => {\r\n        cart.updateQuantity(product1.id, 3);\r\n        expect(cart.items[0].quantity).toBe(3);\r\n      });\r\n      \r\n      test('removes item when quantity is zero', () => {\r\n        cart.updateQuantity(product1.id, 0);\r\n        expect(cart.items).toHaveLength(0);\r\n      });\r\n      \r\n      test('removes item when quantity is negative', () => {\r\n        cart.updateQuantity(product1.id, -1);\r\n        expect(cart.items).toHaveLength(0);\r\n      });\r\n      \r\n      test('throws error when item not found', () => {\r\n        expect(() => cart.updateQuantity(999, 5)).toThrow('Item not found in cart');\r\n      });\r\n    });\r\n    \r\n    describe('discount codes', () => {\r\n      test('applies SAVE10 discount', () => {\r\n        const discount = cart.applyDiscount('SAVE10');\r\n        expect(discount).toBe(0.10);\r\n        expect(cart.discountCode).toBe('SAVE10');\r\n      });\r\n      \r\n      test('applies SAVE20 discount', () => {\r\n        const discount = cart.applyDiscount('SAVE20');\r\n        expect(discount).toBe(0.20);\r\n      });\r\n      \r\n      test('applies WELCOME discount', () => {\r\n        const discount = cart.applyDiscount('WELCOME');\r\n        expect(discount).toBe(0.15);\r\n      });\r\n      \r\n      test('throws error for invalid discount code', () => {\r\n        expect(() => cart.applyDiscount('INVALID')).toThrow('Invalid discount code');\r\n      });\r\n    });\r\n    \r\n    describe('calculations', () => {\r\n      beforeEach(() => {\r\n        cart.addItem(product1, 2); // 2 * 10 = 20\r\n        cart.addItem(product2, 1); // 1 * 20 = 20\r\n        // Subtotal = 40\r\n      });\r\n      \r\n      test('calculates subtotal correctly', () => {\r\n        expect(cart.getSubtotal()).toBe(40);\r\n      });\r\n      \r\n      test('calculates discount with SAVE10', () => {\r\n        cart.applyDiscount('SAVE10');\r\n        expect(cart.getDiscount()).toBe(4); // 40 * 0.10\r\n      });\r\n      \r\n      test('calculates discount with SAVE20', () => {\r\n        cart.applyDiscount('SAVE20');\r\n        expect(cart.getDiscount()).toBe(8); // 40 * 0.20\r\n      });\r\n      \r\n      test('returns 0 discount without code', () => {\r\n        expect(cart.getDiscount()).toBe(0);\r\n      });\r\n      \r\n      test('calculates shipping - free for orders over 100', () => {\r\n        const expensiveProduct = new ProductBuilder().withPrice(150).build();\r\n        const newCart = new ShoppingCart('user-123');\r\n        newCart.addItem(expensiveProduct, 1);\r\n        \r\n        expect(newCart.getShipping()).toBe(0);\r\n      });\r\n      \r\n      test('calculates shipping - $5 for orders 50-99', () => {\r\n        const product = new ProductBuilder().withPrice(60).build();\r\n        const newCart = new ShoppingCart('user-123');\r\n        newCart.addItem(product, 1);\r\n        \r\n        expect(newCart.getShipping()).toBe(5);\r\n      });\r\n      \r\n      test('calculates shipping - $10 for orders under 50', () => {\r\n        expect(cart.getShipping()).toBe(10);\r\n      });\r\n      \r\n      test('calculates total without discount', () => {\r\n        expect(cart.getTotal()).toBe(50); // 40 + 10 shipping\r\n      });\r\n      \r\n      test('calculates total with discount', () => {\r\n        cart.applyDiscount('SAVE10');\r\n        expect(cart.getTotal()).toBe(46); // 40 - 4 + 10\r\n      });\r\n    });\r\n    \r\n    describe('utility methods', () => {\r\n      test('isEmpty returns true for empty cart', () => {\r\n        expect(cart.isEmpty()).toBe(true);\r\n      });\r\n      \r\n      test('isEmpty returns false for non-empty cart', () => {\r\n        cart.addItem(product1, 1);\r\n        expect(cart.isEmpty()).toBe(false);\r\n      });\r\n      \r\n      test('getItemCount returns total quantity', () => {\r\n        cart.addItem(product1, 2);\r\n        cart.addItem(product2, 3);\r\n        expect(cart.getItemCount()).toBe(5);\r\n      });\r\n      \r\n      test('clear removes all items and discount', () => {\r\n        cart.addItem(product1, 1);\r\n        cart.applyDiscount('SAVE10');\r\n        cart.clear();\r\n        \r\n        expect(cart.items).toHaveLength(0);\r\n        expect(cart.discountCode).toBeNull();\r\n      });\r\n    });\r\n  });\r\n  \r\n  // ================== ORDER TESTS ==================\r\n  \r\n  describe('Order', () => {\r\n    let order;\r\n    \r\n    beforeEach(() => {\r\n      order = new Order(1, 'user-123', [], 100);\r\n    });\r\n    \r\n    describe('status transitions', () => {\r\n      test('starts with pending status', () => {\r\n        expect(order.status).toBe('pending');\r\n      });\r\n      \r\n      test('confirms pending order', () => {\r\n        order.confirm();\r\n        expect(order.status).toBe('confirmed');\r\n      });\r\n      \r\n      test('cannot confirm non-pending order', () => {\r\n        order.confirm();\r\n        expect(() => order.confirm()).toThrow('Order can only be confirmed when pending');\r\n      });\r\n      \r\n      test('ships confirmed order', () => {\r\n        order.confirm();\r\n        order.ship();\r\n        expect(order.status).toBe('shipped');\r\n      });\r\n      \r\n      test('cannot ship non-confirmed order', () => {\r\n        expect(() => order.ship()).toThrow('Order must be confirmed before shipping');\r\n      });\r\n      \r\n      test('delivers shipped order', () => {\r\n        order.confirm();\r\n        order.ship();\r\n        order.deliver();\r\n        expect(order.status).toBe('delivered');\r\n      });\r\n      \r\n      test('cannot deliver non-shipped order', () => {\r\n        order.confirm();\r\n        expect(() => order.deliver()).toThrow('Order must be shipped before delivery');\r\n      });\r\n      \r\n      test('cancels pending order', () => {\r\n        order.cancel();\r\n        expect(order.status).toBe('cancelled');\r\n      });\r\n      \r\n      test('cancels confirmed order', () => {\r\n        order.confirm();\r\n        order.cancel();\r\n        expect(order.status).toBe('cancelled');\r\n      });\r\n      \r\n      test('cannot cancel delivered order', () => {\r\n        order.confirm();\r\n        order.ship();\r\n        order.deliver();\r\n        expect(() => order.cancel()).toThrow('Cannot cancel delivered order');\r\n      });\r\n    });\r\n  });\r\n  \r\n  // ================== ORDER SERVICE TESTS ==================\r\n  \r\n  describe('OrderService', () => {\r\n    let orderService;\r\n    let mockPaymentService;\r\n    let cart;\r\n    let product;\r\n    \r\n    beforeEach(() => {\r\n      mockPaymentService = {\r\n        processPayment: jest.fn()\r\n      };\r\n      orderService = new OrderService(mockPaymentService);\r\n      \r\n      cart = new ShoppingCart('user-123');\r\n      product = new ProductBuilder()\r\n        .withStock(10)\r\n        .withPrice(50)\r\n        .build();\r\n      cart.addItem(product, 2);\r\n    });\r\n    \r\n    describe('createOrder()', () => {\r\n      test('creates order successfully', async () => {\r\n        // Arrange\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        const expectedTotal = cart.getTotal(); // Capture before cart is cleared\r\n        \r\n        // Act\r\n        const order = await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        // Assert\r\n        expect(order).toBeInstanceOf(Order);\r\n        expect(order.userId).toBe('user-123');\r\n        expect(order.status).toBe('pending');\r\n        expect(mockPaymentService.processPayment).toHaveBeenCalledWith(\r\n          expectedTotal,\r\n          'credit-card'\r\n        );\r\n      });\r\n      \r\n      test('reduces product stock after order', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        \r\n        const originalStock = product.stock;\r\n        await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        expect(product.stock).toBe(originalStock - 2);\r\n      });\r\n      \r\n      test('clears cart after order', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        \r\n        await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        expect(cart.isEmpty()).toBe(true);\r\n      });\r\n      \r\n      test('throws error for empty cart', async () => {\r\n        const emptyCart = new ShoppingCart('user-123');\r\n        \r\n        await expect(\r\n          orderService.createOrder(emptyCart, 'credit-card')\r\n        ).rejects.toThrow('Cannot create order from empty cart');\r\n      });\r\n      \r\n      test('throws error when payment fails', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: false });\r\n        \r\n        await expect(\r\n          orderService.createOrder(cart, 'credit-card')\r\n        ).rejects.toThrow('Payment failed');\r\n      });\r\n      \r\n      test('does not reduce stock when payment fails', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: false });\r\n        \r\n        const originalStock = product.stock;\r\n        \r\n        try {\r\n          await orderService.createOrder(cart, 'credit-card');\r\n        } catch (e) {\r\n          // Expected to fail\r\n        }\r\n        \r\n        expect(product.stock).toBe(originalStock);\r\n      });\r\n    });\r\n    \r\n    describe('getOrder()', () => {\r\n      test('retrieves existing order', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        const createdOrder = await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        const retrieved = orderService.getOrder(createdOrder.id);\r\n        \r\n        expect(retrieved).toBe(createdOrder);\r\n      });\r\n      \r\n      test('returns null for non-existent order', () => {\r\n        const result = orderService.getOrder(999);\r\n        expect(result).toBeNull();\r\n      });\r\n    });\r\n    \r\n    describe('getUserOrders()', () => {\r\n      test('returns all orders for user', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        \r\n        // Create first order\r\n        await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        // Create second order\r\n        cart.addItem(product, 1);\r\n        await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        const orders = orderService.getUserOrders('user-123');\r\n        \r\n        expect(orders).toHaveLength(2);\r\n        expect(orders.every(o => o.userId === 'user-123')).toBe(true);\r\n      });\r\n      \r\n      test('returns empty array when user has no orders', () => {\r\n        const orders = orderService.getUserOrders('no-orders-user');\r\n        expect(orders).toEqual([]);\r\n      });\r\n    });\r\n    \r\n    describe('cancelOrder()', () => {\r\n      test('cancels order and restores stock', async () => {\r\n        mockPaymentService.processPayment.mockResolvedValue({ success: true });\r\n        const order = await orderService.createOrder(cart, 'credit-card');\r\n        \r\n        const originalStock = product.stock;\r\n        const cancelled = orderService.cancelOrder(order.id);\r\n        \r\n        expect(cancelled.status).toBe('cancelled');\r\n        expect(product.stock).toBe(originalStock + 2);\r\n      });\r\n      \r\n      test('throws error for non-existent order', () => {\r\n        expect(() => orderService.cancelOrder(999)).toThrow('Order not found');\r\n      });\r\n    });\r\n  });\r\n});\r\n\r\n// ============================================\r\n// ADDITIONAL BEST PRACTICES EXAMPLES\r\n// ============================================\r\n\r\ndescribe('Best Practices Examples', () => {\r\n  \r\n  // ================== AAA PATTERN ==================\r\n  \r\n  describe('AAA Pattern', () => {\r\n    test('demonstrates Arrange-Act-Assert', () => {\r\n      // Arrange - Set up test data and dependencies\r\n      const product = new ProductBuilder()\r\n        .withPrice(100)\r\n        .withStock(10)\r\n        .build();\r\n      const cart = new ShoppingCart('user-123');\r\n      \r\n      // Act - Execute the code being tested\r\n      cart.addItem(product, 2);\r\n      cart.applyDiscount('SAVE10');\r\n      const total = cart.getTotal();\r\n      \r\n      // Assert - Verify the results\r\n      expect(total).toBeInRange(180, 180); // 200 - 20 discount + 0 shipping = 180\r\n      expect(cart.getItemCount()).toBe(2);\r\n    });\r\n  });\r\n  \r\n  // ================== ONE CONCEPT PER TEST ==================\r\n  \r\n  describe('One Concept Per Test', () => {\r\n    test('tests only cart creation', () => {\r\n      const cart = new ShoppingCart('user-123');\r\n      expect(cart.userId).toBe('user-123');\r\n      expect(cart.isEmpty()).toBe(true);\r\n    });\r\n    \r\n    test('tests only adding items', () => {\r\n      const cart = new ShoppingCart('user-123');\r\n      const product = new ProductBuilder().build();\r\n      \r\n      cart.addItem(product, 1);\r\n      \r\n      expect(cart.items).toHaveLength(1);\r\n    });\r\n    \r\n    test('tests only discount application', () => {\r\n      const cart = new ShoppingCart('user-123');\r\n      \r\n      cart.applyDiscount('SAVE10');\r\n      \r\n      expect(cart.discountCode).toBe('SAVE10');\r\n    });\r\n  });\r\n  \r\n  // ================== EDGE CASES ==================\r\n  \r\n  describe('Edge Cases', () => {\r\n    test('handles empty cart total', () => {\r\n      const cart = new ShoppingCart('user-123');\r\n      expect(cart.getTotal()).toBe(10); // Just shipping\r\n    });\r\n    \r\n    test('handles cart with one item', () => {\r\n      const cart = new ShoppingCart('user-123');\r\n      const product = new ProductBuilder().withPrice(5).build();\r\n      \r\n      cart.addItem(product, 1);\r\n      \r\n      expect(cart.getTotal()).toBe(15); // 5 + 10 shipping\r\n    });\r\n    \r\n    test('handles maximum stock reduction', () => {\r\n      const product = new ProductBuilder().withStock(5).build();\r\n      \r\n      product.reduceStock(5);\r\n      \r\n      expect(product.stock).toBe(0);\r\n    });\r\n    \r\n    test('handles zero price product', () => {\r\n      const freeProduct = new ProductBuilder().withPrice(0).build();\r\n      const cart = new ShoppingCart('user-123');\r\n      \r\n      cart.addItem(freeProduct, 1);\r\n      \r\n      expect(cart.getSubtotal()).toBe(0);\r\n    });\r\n  });\r\n});\r\n\r\n// ============================================\r\n// RUN TESTS MESSAGE\r\n// ============================================\r\n\r\nconsole.log('âœ… Complete Jest testing guide ready!');\r\nconsole.log('ðŸ“š This covers all 10 steps with real-world examples');\r\nconsole.log('ðŸŽ¯ Run tests to see comprehensive E-Commerce system testing');\r\n\n",
  "description": "## **Step 10: Best Practices & Real-World Project**\r\n\r\n#### **Topic 1: Test Organization and Naming Conventions**\r\n**Explanation:**\r\n\r\n**File Organization:**\r\n```\r\nsrc/\r\n  components/\r\n    Button.js\r\n    Button.test.js\r\n  services/\r\n    api.js\r\n    api.test.js\r\n  utils/\r\n    validation.js\r\n    validation.test.js\r\n```\r\n\r\n**Naming Conventions:**\r\n\r\n**describe blocks** - Describe what you're testing\r\n```javascript\r\ndescribe('UserService', () => {\r\n  describe('createUser()', () => {\r\n    // Tests for createUser method\r\n  });\r\n});\r\n```\r\n\r\n**test names** - Should be readable sentences\r\n```javascript\r\n// âŒ Bad\r\ntest('test1', () => {});\r\ntest('user', () => {});\r\n\r\n// âœ… Good\r\ntest('creates user with valid data', () => {});\r\ntest('throws error when email is invalid', () => {});\r\ntest('returns null when user not found', () => {});\r\n```\r\n\r\n**Pattern: \"should\" vs descriptive**\r\n```javascript\r\n// Both acceptable\r\ntest('should return true for valid email', () => {});\r\ntest('returns true for valid email', () => {});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 2: DRY Principle in Tests**\r\n**Explanation:**\r\n\r\n**Problem: Repetitive test setup**\r\n```javascript\r\n// âŒ Repetitive\r\ntest('test 1', () => {\r\n  const user = { name: 'John', email: 'john@example.com', age: 30 };\r\n  // test code\r\n});\r\n\r\ntest('test 2', () => {\r\n  const user = { name: 'John', email: 'john@example.com', age: 30 };\r\n  // test code\r\n});\r\n```\r\n\r\n**Solution: Use beforeEach**\r\n```javascript\r\n// âœ… DRY\r\ndescribe('UserService', () => {\r\n  let user;\r\n  \r\n  beforeEach(() => {\r\n    user = { name: 'John', email: 'john@example.com', age: 30 };\r\n  });\r\n  \r\n  test('test 1', () => {\r\n    // use user\r\n  });\r\n  \r\n  test('test 2', () => {\r\n    // use user\r\n  });\r\n});\r\n```\r\n\r\n**Helper Functions:**\r\n```javascript\r\nfunction createTestUser(overrides = {}) {\r\n  return {\r\n    name: 'John',\r\n    email: 'john@example.com',\r\n    age: 30,\r\n    ...overrides\r\n  };\r\n}\r\n\r\ntest('test with custom age', () => {\r\n  const user = createTestUser({ age: 25 });\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 3: Test Data Builders (Builder Pattern)**\r\n**Explanation:**\r\n\r\n**Builder Pattern** - Fluent API for creating test data\r\n\r\n```javascript\r\nclass UserBuilder {\r\n  constructor() {\r\n    this.user = {\r\n      name: 'John Doe',\r\n      email: 'john@example.com',\r\n      age: 30,\r\n      role: 'user'\r\n    };\r\n  }\r\n  \r\n  withName(name) {\r\n    this.user.name = name;\r\n    return this;\r\n  }\r\n  \r\n  withEmail(email) {\r\n    this.user.email = email;\r\n    return this;\r\n  }\r\n  \r\n  withAge(age) {\r\n    this.user.age = age;\r\n    return this;\r\n  }\r\n  \r\n  asAdmin() {\r\n    this.user.role = 'admin';\r\n    return this;\r\n  }\r\n  \r\n  build() {\r\n    return { ...this.user };\r\n  }\r\n}\r\n\r\n// Usage\r\ntest('admin user', () => {\r\n  const admin = new UserBuilder()\r\n    .withName('Admin User')\r\n    .asAdmin()\r\n    .build();\r\n  \r\n  expect(admin.role).toBe('admin');\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 4: Custom Matchers with expect.extend()**\r\n**Explanation:**\r\n\r\n**Create domain-specific matchers:**\r\n\r\n```javascript\r\nexpect.extend({\r\n  toBeValidEmail(received) {\r\n    const pass = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(received);\r\n    return {\r\n      pass,\r\n      message: () => \r\n        pass\r\n          ? `expected \\${received} not to be a valid email`\r\n          : `expected \\${received} to be a valid email`\r\n    };\r\n  }\r\n});\r\n\r\n// Usage\r\ntest('validates email', () => {\r\n  expect('test@example.com').toBeValidEmail();\r\n  expect('invalid').not.toBeValidEmail();\r\n});\r\n```\r\n\r\n**More examples:**\r\n```javascript\r\nexpect.extend({\r\n  toBeWithinRange(received, min, max) {\r\n    const pass = received >= min && received <= max;\r\n    return {\r\n      pass,\r\n      message: () => \r\n        `expected \\${received} to be within range \\${min}-\\${max}`\r\n    };\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 5: Arrange-Act-Assert (AAA) Pattern**\r\n**Explanation:**\r\n\r\n**AAA Pattern** - Structure tests in 3 clear phases\r\n\r\n```javascript\r\ntest('calculates order total correctly', () => {\r\n  // Arrange - Set up test data\r\n  const order = {\r\n    items: [\r\n      { price: 10, quantity: 2 },\r\n      { price: 20, quantity: 1 }\r\n    ]\r\n  };\r\n  const calculator = new OrderCalculator();\r\n  \r\n  // Act - Execute the code being tested\r\n  const total = calculator.calculateTotal(order);\r\n  \r\n  // Assert - Verify the result\r\n  expect(total).toBe(40);\r\n});\r\n```\r\n\r\n**With comments (for clarity):**\r\n```javascript\r\ntest('user registration flow', async () => {\r\n  // Arrange\r\n  const userData = { name: 'John', email: 'john@example.com' };\r\n  const userService = new UserService();\r\n  \r\n  // Act\r\n  const user = await userService.register(userData);\r\n  \r\n  // Assert\r\n  expect(user).toHaveProperty('id');\r\n  expect(user.name).toBe('John');\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 6: One Concept Per Test**\r\n**Explanation:**\r\n\r\n**Problem: Testing multiple things**\r\n```javascript\r\n// âŒ Bad - Tests too much\r\ntest('user operations', () => {\r\n  const user = createUser({ name: 'John' });\r\n  expect(user.name).toBe('John');\r\n  \r\n  user.update({ name: 'Jane' });\r\n  expect(user.name).toBe('Jane');\r\n  \r\n  user.delete();\r\n  expect(user.isDeleted).toBe(true);\r\n});\r\n```\r\n\r\n**Solution: One test, one concept**\r\n```javascript\r\n// âœ… Good - Focused tests\r\ntest('creates user with provided name', () => {\r\n  const user = createUser({ name: 'John' });\r\n  expect(user.name).toBe('John');\r\n});\r\n\r\ntest('updates user name', () => {\r\n  const user = createUser({ name: 'John' });\r\n  user.update({ name: 'Jane' });\r\n  expect(user.name).toBe('Jane');\r\n});\r\n\r\ntest('marks user as deleted', () => {\r\n  const user = createUser({ name: 'John' });\r\n  user.delete();\r\n  expect(user.isDeleted).toBe(true);\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 7: Integration vs Unit Tests**\r\n**Explanation:**\r\n\r\n**Unit Test** - Tests one piece in isolation\r\n```javascript\r\n// Unit test - mocks all dependencies\r\ntest('UserService.createUser calls API', async () => {\r\n  const mockApi = { post: jest.fn().mockResolvedValue({ id: 1 }) };\r\n  const service = new UserService(mockApi);\r\n  \r\n  await service.createUser({ name: 'John' });\r\n  \r\n  expect(mockApi.post).toHaveBeenCalled();\r\n});\r\n```\r\n\r\n**Integration Test** - Tests multiple pieces together\r\n```javascript\r\n// Integration test - uses real dependencies\r\ntest('UserService creates and retrieves user', async () => {\r\n  const api = new ApiClient(); // Real API\r\n  const service = new UserService(api);\r\n  \r\n  const created = await service.createUser({ name: 'John' });\r\n  const retrieved = await service.getUser(created.id);\r\n  \r\n  expect(retrieved.name).toBe('John');\r\n});\r\n```\r\n\r\n**When to use:**\r\n- Unit tests: Most of your tests (fast, isolated)\r\n- Integration tests: Critical paths (slower, more realistic)\r\n\r\n---\r\n\r\n#### **Topic 8: Test File Structure**\r\n**Explanation:**\r\n\r\n**Recommended structure:**\r\n```javascript\r\n// Imports\r\nimport { UserService } from './UserService';\r\nimport { mockApi } from '../test-utils/mocks';\r\n\r\n// Test data and helpers at the top\r\nconst validUserData = { name: 'John', email: 'john@example.com' };\r\n\r\nfunction createTestUser(overrides = {}) {\r\n  return { ...validUserData, ...overrides };\r\n}\r\n\r\n// Main describe block\r\ndescribe('UserService', () => {\r\n  let service;\r\n  let api;\r\n  \r\n  // Setup/teardown\r\n  beforeEach(() => {\r\n    api = mockApi();\r\n    service = new UserService(api);\r\n  });\r\n  \r\n  // Grouped tests\r\n  describe('createUser()', () => {\r\n    test('creates user with valid data', () => {\r\n      // test\r\n    });\r\n    \r\n    test('throws error with invalid data', () => {\r\n      // test\r\n    });\r\n  });\r\n  \r\n  describe('getUser()', () => {\r\n    test('retrieves existing user', () => {\r\n      // test\r\n    });\r\n    \r\n    test('returns null for non-existent user', () => {\r\n      // test\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 9: Testing Edge Cases**\r\n**Explanation:**\r\n\r\n**Common edge cases:**\r\n\r\n**Empty/Null Values:**\r\n```javascript\r\ntest('handles empty string', () => {\r\n  expect(validateName('')).toBe(false);\r\n});\r\n\r\ntest('handles null', () => {\r\n  expect(validateName(null)).toBe(false);\r\n});\r\n\r\ntest('handles undefined', () => {\r\n  expect(validateName(undefined)).toBe(false);\r\n});\r\n```\r\n\r\n**Boundary Values:**\r\n```javascript\r\ntest('age validation boundaries', () => {\r\n  expect(isValidAge(17)).toBe(false); // Just below\r\n  expect(isValidAge(18)).toBe(true);  // Lower bound\r\n  expect(isValidAge(65)).toBe(true);  // Upper bound\r\n  expect(isValidAge(66)).toBe(false); // Just above\r\n});\r\n```\r\n\r\n**Large/Small Values:**\r\n```javascript\r\ntest('handles very large numbers', () => {\r\n  expect(add(Number.MAX_SAFE_INTEGER, 1)).toBeDefined();\r\n});\r\n\r\ntest('handles empty array', () => {\r\n  expect(sum([])).toBe(0);\r\n});\r\n\r\ntest('handles single item array', () => {\r\n  expect(sum([5])).toBe(5);\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 10: Error Handling in Tests**\r\n**Explanation:**\r\n\r\n**Testing exceptions:**\r\n```javascript\r\ntest('throws specific error', () => {\r\n  expect(() => divide(10, 0)).toThrow('Cannot divide by zero');\r\n  expect(() => divide(10, 0)).toThrow(Error);\r\n  expect(() => divide(10, 0)).toThrow(/divide/);\r\n});\r\n```\r\n\r\n**Testing async errors:**\r\n```javascript\r\ntest('rejects with error', async () => {\r\n  await expect(fetchUser(999)).rejects.toThrow('User not found');\r\n});\r\n\r\ntest('catches async error', async () => {\r\n  try {\r\n    await fetchUser(999);\r\n    fail('Should have thrown');\r\n  } catch (error) {\r\n    expect(error.message).toBe('User not found');\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 11: Test Independence**\r\n**Explanation:**\r\n\r\n**Problem: Tests depend on each other**\r\n```javascript\r\n// âŒ Bad - Tests are coupled\r\nlet userId;\r\n\r\ntest('creates user', () => {\r\n  userId = createUser().id; // Sets global state\r\n});\r\n\r\ntest('updates user', () => {\r\n  updateUser(userId); // Depends on previous test!\r\n});\r\n```\r\n\r\n**Solution: Independent tests**\r\n```javascript\r\n// âœ… Good - Each test is independent\r\ntest('creates user', () => {\r\n  const user = createUser();\r\n  expect(user).toHaveProperty('id');\r\n});\r\n\r\ntest('updates user', () => {\r\n  const user = createUser(); // Create own data\r\n  const updated = updateUser(user.id);\r\n  expect(updated.id).toBe(user.id);\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 12: Descriptive Test Names**\r\n**Explanation:**\r\n\r\n**Bad names:**\r\n```javascript\r\n// âŒ Too vague\r\ntest('works', () => {});\r\ntest('test1', () => {});\r\ntest('user', () => {});\r\n```\r\n\r\n**Good names:**\r\n```javascript\r\n// âœ… Clear and descriptive\r\ntest('creates user with valid email', () => {});\r\ntest('throws error when email is missing', () => {});\r\ntest('returns empty array when no users exist', () => {});\r\ntest('calculates 10% discount for premium members', () => {});\r\n```\r\n\r\n**Pattern: \"when...then\"**\r\n```javascript\r\ntest('when user is premium, applies 20% discount', () => {});\r\ntest('when cart is empty, returns total of 0', () => {});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 13: Complete Real-World E-Commerce Example**\r\n**Explanation:**\r\n\r\nA professional test suite for an e-commerce system covering:\r\n- Product catalog\r\n- Shopping cart\r\n- Order processing\r\n- User authentication\r\n- Payment processing\r\n\r\n---\r\n\r\n#### **Topic 14: Professional Test Suite Organization**\r\n**Explanation:**\r\n\r\n**Directory Structure:**\r\n```\r\nsrc/\r\n  models/\r\n    Product.js\r\n    Product.test.js\r\n    Cart.js\r\n    Cart.test.js\r\n  services/\r\n    OrderService.js\r\n    OrderService.test.js\r\n  utils/\r\n    validation.js\r\n    validation.test.js\r\n  test-utils/\r\n    builders/\r\n      ProductBuilder.js\r\n      UserBuilder.js\r\n    mocks/\r\n      mockApi.js\r\n    fixtures/\r\n      products.js\r\n      users.js\r\n```"
};

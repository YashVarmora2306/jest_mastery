import { Step } from '../types';

export const step9: Step = {
  "id": "9",
  "title": "Code Coverage - Measuring Test Effectiveness",
  "initialCode": "// ============================================\r\n// STEP 9: Code Coverage\r\n// ============================================\r\n\r\n// Note: The playground can't generate actual coverage reports,\r\n// but we can demonstrate writing tests to cover all branches.\r\n\r\n// Function with multiple branches to test\r\nfunction calculateDiscount(price, userType, hasCoupon) {\r\n  // Branch 1: Invalid input\r\n  if (price < 0) {\r\n    throw new Error('Price cannot be negative');\r\n  }\r\n\r\n  let discount = 0;\r\n\r\n  // Branch 2: VIP User\r\n  if (userType === 'VIP') {\r\n    discount = 0.20; // 20%\r\n  } \r\n  // Branch 3: Regular User\r\n  else if (userType === 'REGULAR') {\r\n    discount = 0.05; // 5%\r\n  }\r\n  // Branch 4: Other user types (implicit else)\r\n  \r\n  // Branch 5: Coupon bonus\r\n  if (hasCoupon) {\r\n    discount += 0.10; // Extra 10%\r\n  }\r\n\r\n  // Branch 6: Max discount cap\r\n  if (discount > 0.50) {\r\n    discount = 0.50;\r\n  }\r\n\r\n  return price * (1 - discount);\r\n}\r\n\r\n// Complex logic function\r\nfunction validatePassword(password, options = {}) {\r\n  const { minLength = 8, requireNumbers = true } = options;\r\n  \r\n  // Branch 1: Length check\r\n  if (password.length < minLength) {\r\n    return { valid: false, reason: 'Too short' };\r\n  }\r\n  \r\n  // Branch 2: Number check\r\n  if (requireNumbers && !/\\d/.test(password)) {\r\n    return { valid: false, reason: 'Missing number' };\r\n  }\r\n  \r\n  return { valid: true };\r\n}\r\n\r\n// ============================================\r\n// EXAMPLE 1: Testing All Branches (100% Coverage)\r\n// ============================================\r\n\r\ndescribe('calculateDiscount Coverage', () => {\r\n  // Branch 1: Invalid input\r\n  test('throws error for negative price', () => {\r\n    expect(() => calculateDiscount(-10, 'REGULAR', false))\r\n      .toThrow('Price cannot be negative');\r\n  });\r\n\r\n  // Branch 2: VIP User (no coupon)\r\n  test('calculates VIP discount', () => {\r\n    // 100 * (1 - 0.20) = 80\r\n    expect(calculateDiscount(100, 'VIP', false)).toBe(80);\r\n  });\r\n\r\n  // Branch 3: Regular User (no coupon)\r\n  test('calculates Regular discount', () => {\r\n    // 100 * (1 - 0.05) = 95\r\n    expect(calculateDiscount(100, 'REGULAR', false)).toBe(95);\r\n  });\r\n\r\n  // Branch 4: Other User (no coupon)\r\n  test('calculates no discount for guest', () => {\r\n    // 100 * (1 - 0) = 100\r\n    expect(calculateDiscount(100, 'GUEST', false)).toBe(100);\r\n  });\r\n\r\n  // Branch 5: Coupon bonus (VIP + Coupon)\r\n  test('calculates VIP with coupon', () => {\r\n    // 100 * (1 - (0.20 + 0.10)) = 70\r\n    expect(calculateDiscount(100, 'VIP', true)).toBe(70);\r\n  });\r\n  \r\n  // Branch 5: Coupon bonus (Guest + Coupon)\r\n  test('calculates Guest with coupon', () => {\r\n    // 100 * (1 - (0 + 0.10)) = 90\r\n    expect(calculateDiscount(100, 'GUEST', true)).toBe(90);\r\n  });\r\n\r\n  // Branch 6: Max discount cap (Hypothetical scenario)\r\n  // We need to force discount > 0.50\r\n  // Let's say we have a SUPER_VIP with 50% base discount + coupon\r\n  // But wait, our function only handles VIP (20%) and REGULAR (5%)\r\n  // So we can't reach Branch 6 with current logic!\r\n  // This reveals unreachable code or missing logic.\r\n  \r\n  // Let's assume we modify the function or inputs to reach it.\r\n  // For now, this branch is UNCOVERED.\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 2: Testing Complex Logic\r\n// ============================================\r\n\r\ndescribe('validatePassword Coverage', () => {\r\n  // Branch 1: Length check (True)\r\n  test('rejects short passwords', () => {\r\n    expect(validatePassword('short')).toEqual({ valid: false, reason: 'Too short' });\r\n  });\r\n\r\n  // Branch 1: Length check (False) -> Continue\r\n  // Branch 2: Number check (True && True) -> Reject\r\n  test('rejects password without numbers', () => {\r\n    expect(validatePassword('password', { requireNumbers: true }))\r\n      .toEqual({ valid: false, reason: 'Missing number' });\r\n  });\r\n\r\n  // Branch 2: Number check (False) -> Skip\r\n  test('accepts password without numbers if not required', () => {\r\n    expect(validatePassword('password', { requireNumbers: false }))\r\n      .toEqual({ valid: true });\r\n  });\r\n\r\n  // Branch 2: Number check (True && False) -> Accept\r\n  test('accepts valid password with numbers', () => {\r\n    expect(validatePassword('password123'))\r\n      .toEqual({ valid: true });\r\n  });\r\n  \r\n  // Default options coverage\r\n  test('uses default options', () => {\r\n    expect(validatePassword('pass1234')).toEqual({ valid: true });\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 3: Identifying Missing Tests\r\n// ============================================\r\n\r\nfunction processOrder(order) {\r\n  if (!order.items || order.items.length === 0) {\r\n    return 'Empty';\r\n  }\r\n  \r\n  if (order.total > 1000) {\r\n    if (order.isMember) {\r\n      return 'Free Shipping';\r\n    } else {\r\n      return 'Standard Shipping';\r\n    }\r\n  }\r\n  \r\n  return 'Standard Shipping';\r\n}\r\n\r\ndescribe('processOrder - Partial Coverage', () => {\r\n  test('returns Empty for no items', () => {\r\n    expect(processOrder({})).toBe('Empty');\r\n  });\r\n  \r\n  test('returns Standard Shipping for small orders', () => {\r\n    expect(processOrder({ items: ['a'], total: 50 })).toBe('Standard Shipping');\r\n  });\r\n  \r\n  // MISSING TESTS:\r\n  // 1. Large order (> 1000) + Member -> 'Free Shipping'\r\n  // 2. Large order (> 1000) + Non-Member -> 'Standard Shipping'\r\n  \r\n  // Adding missing tests:\r\n  test('returns Free Shipping for large member orders', () => {\r\n    expect(processOrder({ items: ['a'], total: 1500, isMember: true }))\r\n      .toBe('Free Shipping');\r\n  });\r\n  \r\n  test('returns Standard Shipping for large non-member orders', () => {\r\n    expect(processOrder({ items: ['a'], total: 1500, isMember: false }))\r\n      .toBe('Standard Shipping');\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 4: Edge Cases often missed\r\n// ============================================\r\n\r\nfunction getFirstItem(array) {\r\n  if (!array) return null;\r\n  if (array.length === 0) return undefined;\r\n  return array[0];\r\n}\r\n\r\ndescribe('getFirstItem Edge Cases', () => {\r\n  test('returns item for non-empty array', () => {\r\n    expect(getFirstItem([1, 2])).toBe(1);\r\n  });\r\n  \r\n  // Often missed: null/undefined input\r\n  test('returns null for null input', () => {\r\n    expect(getFirstItem(null)).toBeNull();\r\n  });\r\n  \r\n  test('returns null for undefined input', () => {\r\n    expect(getFirstItem(undefined)).toBeNull();\r\n  });\r\n  \r\n  // Often missed: empty array\r\n  test('returns undefined for empty array', () => {\r\n    expect(getFirstItem([])).toBeUndefined();\r\n  });\r\n});\n",
  "description": "## **Step 9: Code Coverage**\r\n\r\n#### **Topic 1: What is Code Coverage?**\r\n**Explanation:**\r\nCode coverage measures how much of your source code is executed when your tests run. It helps identify untested parts of your application.\r\n\r\n**Metrics:**\r\n- **Statements:** % of statements executed\r\n- **Branches:** % of if/else/switch branches executed\r\n- **Functions:** % of functions called\r\n- **Lines:** % of executable lines of code\r\n\r\n**Goal:** High coverage gives confidence, but 100% coverage doesn't guarantee bug-free code!\r\n\r\n---\r\n\r\n#### **Topic 2: Generating Coverage Reports**\r\n**Explanation:**\r\nRun Jest with the `--coverage` flag to generate reports.\r\n\r\n```bash\r\nnpm test -- --coverage\r\n```\r\n\r\n**Output:**\r\n```\r\n-----------------|---------|----------|---------|---------|-------------------\r\nFile             | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \r\n-----------------|---------|----------|---------|---------|-------------------\r\nAll files        |   95.23 |    83.33 |     100 |   95.23 |                   \r\n calculator.js   |     100 |      100 |     100 |     100 |                   \r\n user.js         |   90.91 |       75 |     100 |   90.91 | 15                \r\n-----------------|---------|----------|---------|---------|-------------------\r\n```\r\n\r\n---\r\n\r\n#### **Topic 3: Interpreting Coverage Reports**\r\n**Explanation:**\r\n\r\n**Green:** High coverage (good)\r\n**Yellow:** Medium coverage (needs improvement)\r\n**Red:** Low coverage (critical gaps)\r\n\r\n**Uncovered Lines:** Shows exactly which lines were not executed.\r\n- `15`: Line 15 was never run\r\n- `15-20`: Lines 15 through 20 were never run\r\n\r\n**Branch Coverage:**\r\nIf you have `if (a && b)`, you need tests for:\r\n1. `a` is true, `b` is true\r\n2. `a` is false\r\n3. `a` is true, `b` is false\r\n\r\n---\r\n\r\n#### **Topic 4: Configuring Coverage**\r\n**Explanation:**\r\nConfigure coverage settings in `jest.config.js` or `package.json`.\r\n\r\n```javascript\r\n// jest.config.js\r\nmodule.exports = {\r\n  collectCoverage: true,\r\n  coverageDirectory: 'coverage',\r\n  collectCoverageFrom: [\r\n    'src/**/*.{js,jsx}',\r\n    '!src/index.js', // Exclude entry point\r\n    '!**/node_modules/**'\r\n  ],\r\n  coverageReporters: ['text', 'lcov', 'html']\r\n};\r\n```\r\n\r\n---\r\n\r\n#### **Topic 5: Coverage Thresholds**\r\n**Explanation:**\r\nEnforce minimum coverage requirements. Tests will fail if coverage drops below these values.\r\n\r\n```javascript\r\n// jest.config.js\r\nmodule.exports = {\r\n  coverageThreshold: {\r\n    global: {\r\n      branches: 80,\r\n      functions: 80,\r\n      lines: 80,\r\n      statements: 80\r\n    },\r\n    './src/critical-file.js': {\r\n      branches: 100,\r\n      functions: 100,\r\n      lines: 100,\r\n      statements: 100\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n#### **Topic 6: Ignoring Code for Coverage**\r\n**Explanation:**\r\nSometimes you can't or shouldn't test certain code (e.g., platform-specific code). Use comments to ignore.\r\n\r\n```javascript\r\n/* istanbul ignore next */\r\nif (process.env.NODE_ENV === 'production') {\r\n  console.log('Running in production');\r\n}\r\n\r\n/* istanbul ignore if */\r\nif (unreachableCondition) {\r\n  // ...\r\n}\r\n\r\n/* istanbul ignore file */\r\n// Ignores entire file\r\n```\r\n\r\n---\r\n\r\n#### **Topic 7: Branch Coverage Example**\r\n**Explanation:**\r\nAchieving 100% branch coverage requires testing all paths.\r\n\r\n```javascript\r\nfunction getStatus(age, isStudent) {\r\n  if (age < 18) {\r\n    return 'Child';\r\n  } else if (age < 65) {\r\n    if (isStudent) {\r\n      return 'Student';\r\n    }\r\n    return 'Adult';\r\n  } else {\r\n    return 'Senior';\r\n  }\r\n}\r\n```\r\n\r\n**Tests needed:**\r\n1. `age < 18` (Child)\r\n2. `age >= 18 && age < 65 && isStudent` (Student)\r\n3. `age >= 18 && age < 65 && !isStudent` (Adult)\r\n4. `age >= 65` (Senior)\r\n\r\n---\r\n\r\n#### **Topic 8: Common Coverage Pitfalls**\r\n**Explanation:**\r\n\r\n**1. Testing Implementation Details**\r\nWriting tests just to satisfy coverage rather than testing behavior.\r\n\r\n**2. Ignoring Edge Cases**\r\n100% line coverage doesn't mean all edge cases are handled (e.g., null values, empty arrays).\r\n\r\n**3. False Confidence**\r\nTests might run the code but not assert anything meaningful.\r\n\r\n```javascript\r\ntest('bad test', () => {\r\n  calculateTotal(10, 20); // Runs code, increases coverage\r\n  // No expect()!\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 9: Continuous Integration (CI)**\r\n**Explanation:**\r\nIntegrate coverage checks into your CI/CD pipeline (GitHub Actions, Jenkins, etc.).\r\n\r\n- Fail build if coverage drops\r\n- Upload coverage reports (Codecov, Coveralls)\r\n- Track coverage trends over time\r\n\r\n---\r\n\r\n#### **Topic 10: Visualizing Coverage**\r\n**Explanation:**\r\nUse the HTML report (`coverage/lcov-report/index.html`) to visually inspect coverage.\r\n- Clickable file navigation\r\n- Source code view with highlighted lines\r\n- Easy to spot missed branches"
};

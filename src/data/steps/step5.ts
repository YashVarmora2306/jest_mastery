import { Step } from '../types';

export const step5: Step = {
  "id": "5",
  "title": "Asynchronous Testing - Promises, Async/Await, and Callbacks",
  "initialCode": "// ============================================\r\n// STEP 5: Asynchronous Testing\r\n// ============================================\r\n\r\n// Simulated async functions for testing\r\n\r\n// Callback-based function\r\nfunction fetchDataCallback(callback) {\r\n  setTimeout(() => {\r\n    callback('data from callback');\r\n  }, 100);\r\n}\r\n\r\nfunction fetchDataCallbackWithError(callback) {\r\n  setTimeout(() => {\r\n    callback(new Error('callback error'));\r\n  }, 100);\r\n}\r\n\r\n// Promise-based functions\r\nfunction fetchDataPromise() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('data from promise');\r\n    }, 100);\r\n  });\r\n}\r\n\r\nfunction fetchDataPromiseReject() {\r\n  return new Promise((_, reject) => {\r\n    setTimeout(() => {\r\n      reject(new Error('promise rejected'));\r\n    }, 100);\r\n  });\r\n}\r\n\r\n// Async/await function\r\nasync function fetchDataAsync() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('data from async');\r\n    }, 100);\r\n  });\r\n}\r\n\r\nasync function fetchDataAsyncError() {\r\n  return new Promise((_, reject) => {\r\n    setTimeout(() => {\r\n      reject(new Error('async error'));\r\n    }, 100);\r\n  });\r\n}\r\n\r\n// Simulated API calls\r\nfunction fetchUser(id) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve({ id, name: 'John Doe', email: 'john@example.com' });\r\n    }, 100);\r\n  });\r\n}\r\n\r\nfunction fetchPosts(userId) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve([\r\n        { id: 1, title: 'Post 1', userId },\r\n        { id: 2, title: 'Post 2', userId }\r\n      ]);\r\n    }, 100);\r\n  });\r\n}\r\n\r\nfunction fetchComments(postId) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve([\r\n        { id: 1, text: 'Comment 1', postId },\r\n        { id: 2, text: 'Comment 2', postId }\r\n      ]);\r\n    }, 100);\r\n  });\r\n}\r\n\r\n// ============================================\r\n// EXAMPLE 1: Testing Callbacks with done\r\n// ============================================\r\n\r\ntest('callback returns data - using done', (done) => {\r\n  fetchDataCallback((data) => {\r\n    expect(data).toBe('data from callback');\r\n    done(); // Must call done() to signal test completion\r\n  });\r\n});\r\n\r\ntest('callback with error - using done', (done) => {\r\n  fetchDataCallbackWithError((error) => {\r\n    expect(error.message).toBe('callback error');\r\n    done();\r\n  });\r\n});\r\n\r\n// Wrong way - test passes before callback runs!\r\n// test('wrong - without done', () => {\r\n//   fetchDataCallback((data) => {\r\n//     expect(data).toBe('wrong'); // This never actually runs!\r\n//   });\r\n// });\r\n\r\n// ============================================\r\n// EXAMPLE 2: Testing Promises with .then()\r\n// ============================================\r\n\r\ntest('promise resolves - using .then()', () => {\r\n  return fetchDataPromise().then(data => {\r\n    expect(data).toBe('data from promise');\r\n  }); // Must return the promise!\r\n});\r\n\r\ntest('promise rejects - using .catch()', () => {\r\n  return fetchDataPromiseReject().catch(error => {\r\n    expect(error.message).toBe('promise rejected');\r\n  });\r\n});\r\n\r\n// Wrong way - without return!\r\n// test('wrong - without return', () => {\r\n//   fetchDataPromise().then(data => {\r\n//     expect(data).toBe('data from promise'); // Jest doesn't wait!\r\n//   });\r\n// });\r\n\r\n// ============================================\r\n// EXAMPLE 3: Testing with async/await\r\n// ============================================\r\n\r\ntest('async/await - successful', async () => {\r\n  const data = await fetchDataAsync();\r\n  expect(data).toBe('data from async');\r\n});\r\n\r\ntest('async/await - with error using try/catch', async () => {\r\n  try {\r\n    await fetchDataAsyncError();\r\n  } catch (error) {\r\n    expect(error.message).toBe('async error');\r\n  }\r\n});\r\n\r\ntest('async/await - multiple operations', async () => {\r\n  const user = await fetchUser(1);\r\n  const posts = await fetchPosts(user.id);\r\n  \r\n  expect(user.name).toBe('John Doe');\r\n  expect(posts).toHaveLength(2);\r\n  expect(posts[0].userId).toBe(1);\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 4: .resolves and .rejects Matchers\r\n// ============================================\r\n\r\ntest('.resolves matcher', () => {\r\n  return expect(fetchDataPromise()).resolves.toBe('data from promise');\r\n});\r\n\r\ntest('.resolves with async/await', async () => {\r\n  await expect(fetchDataAsync()).resolves.toBe('data from async');\r\n});\r\n\r\ntest('.rejects matcher', () => {\r\n  return expect(fetchDataPromiseReject()).rejects.toThrow('promise rejected');\r\n});\r\n\r\ntest('.rejects with async/await', async () => {\r\n  await expect(fetchDataAsyncError()).rejects.toThrow('async error');\r\n});\r\n\r\ntest('.resolves with object matching', async () => {\r\n  await expect(fetchUser(1)).resolves.toMatchObject({\r\n    id: 1,\r\n    name: 'John Doe'\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 5: Handling Timeouts\r\n// ============================================\r\n\r\nfunction slowOperation() {\r\n  return new Promise((resolve) => {\r\n    setTimeout(() => {\r\n      resolve('completed');\r\n    }, 2000);\r\n  });\r\n}\r\n\r\ntest('operation with custom timeout', async () => {\r\n  const result = await slowOperation();\r\n  expect(result).toBe('completed');\r\n}, 3000); // 3 second timeout\r\n\r\n// ============================================\r\n// EXAMPLE 6: Testing Parallel Async Operations\r\n// ============================================\r\n\r\ntest('parallel async with Promise.all', async () => {\r\n  const [user, posts, comments] = await Promise.all([\r\n    fetchUser(1),\r\n    fetchPosts(1),\r\n    fetchComments(1)\r\n  ]);\r\n  \r\n  expect(user.id).toBe(1);\r\n  expect(posts).toHaveLength(2);\r\n  expect(comments).toHaveLength(2);\r\n});\r\n\r\ntest('parallel operations with separate awaits', async () => {\r\n  const userPromise = fetchUser(1);\r\n  const postsPromise = fetchPosts(1);\r\n  const commentsPromise = fetchComments(1);\r\n  \r\n  const user = await userPromise;\r\n  const posts = await postsPromise;\r\n  const comments = await commentsPromise;\r\n  \r\n  expect(user).toBeDefined();\r\n  expect(posts).toBeDefined();\r\n  expect(comments).toBeDefined();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 7: Common Mistakes and Fixes\r\n// ============================================\r\n\r\n// CORRECT: Using expect.assertions to ensure callback runs\r\ntest('callback runs with expect.assertions', (done) => {\r\n  expect.assertions(1); // Ensures 1 assertion is called\r\n  \r\n  fetchDataCallback((data) => {\r\n    expect(data).toBe('data from callback');\r\n    done();\r\n  });\r\n});\r\n\r\n// CORRECT: Testing promise rejection properly\r\ntest('promise rejection with expect.assertions', async () => {\r\n  expect.assertions(1);\r\n  \r\n  try {\r\n    await fetchDataAsyncError();\r\n  } catch (error) {\r\n    expect(error.message).toBe('async error');\r\n  }\r\n});\r\n\r\n// CORRECT: Ensuring async code completes\r\ntest('async with assertion count', async () => {\r\n  expect.assertions(2);\r\n  \r\n  const user = await fetchUser(1);\r\n  expect(user.id).toBe(1);\r\n  expect(user.name).toBe('John Doe');\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 8: Sequential vs Parallel Operations\r\n// ============================================\r\n\r\ntest('sequential async operations', async () => {\r\n  // Each operation waits for the previous one\r\n  const user = await fetchUser(1);\r\n  const posts = await fetchPosts(user.id);\r\n  const comments = await fetchComments(posts[0].id);\r\n  \r\n  expect(user.id).toBe(1);\r\n  expect(posts[0].userId).toBe(user.id);\r\n  expect(comments[0].postId).toBe(posts[0].id);\r\n});\r\n\r\ntest('parallel async operations - faster', async () => {\r\n  // All operations start at the same time\r\n  const [user1, user2, user3] = await Promise.all([\r\n    fetchUser(1),\r\n    fetchUser(2),\r\n    fetchUser(3)\r\n  ]);\r\n  \r\n  expect(user1.id).toBe(1);\r\n  expect(user2.id).toBe(2);\r\n  expect(user3.id).toBe(3);\r\n});\r\n\r\ntest('mixed sequential and parallel', async () => {\r\n  // Get user first\r\n  const user = await fetchUser(1);\r\n  \r\n  // Then get posts and comments in parallel\r\n  const [posts, userComments] = await Promise.all([\r\n    fetchPosts(user.id),\r\n    fetchComments(1)\r\n  ]);\r\n  \r\n  expect(posts).toHaveLength(2);\r\n  expect(userComments).toHaveLength(2);\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 9: Real-World Async Testing\r\n// ============================================\r\n\r\n// Simulated API service\r\nconst apiService = {\r\n  async login(username, password) {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    if (username === 'admin' && password === 'password') {\r\n      return { token: 'abc123', user: { username: 'admin' } };\r\n    }\r\n    throw new Error('Invalid credentials');\r\n  },\r\n  \r\n  async fetchDashboard(token) {\r\n    await new Promise(resolve => setTimeout(resolve, 100));\r\n    if (token === 'abc123') {\r\n      return { stats: { users: 100, posts: 500 } };\r\n    }\r\n    throw new Error('Unauthorized');\r\n  }\r\n};\r\n\r\ndescribe('API Service', () => {\r\n  test('successful login flow', async () => {\r\n    const loginResult = await apiService.login('admin', 'password');\r\n    expect(loginResult.token).toBe('abc123');\r\n    \r\n    const dashboard = await apiService.fetchDashboard(loginResult.token);\r\n    expect(dashboard.stats.users).toBe(100);\r\n  });\r\n  \r\n  test('failed login', async () => {\r\n    await expect(\r\n      apiService.login('wrong', 'credentials')\r\n    ).rejects.toThrow('Invalid credentials');\r\n  });\r\n  \r\n  test('unauthorized dashboard access', async () => {\r\n    await expect(\r\n      apiService.fetchDashboard('invalid-token')\r\n    ).rejects.toThrow('Unauthorized');\r\n  });\r\n});\n",
  "description": "## **Step 5: Asynchronous Testing**\r\n\r\n#### **Topic 1: Testing Callbacks with done**\r\n**Explanation:**\r\nFor callback-based async code, Jest provides a `done` callback. Call `done()` when the async operation completes. If `done()` is never called, the test fails with a timeout.\r\n\r\n**Syntax:**\r\n```javascript\r\ntest('async with callback', (done) => {\r\n  asyncFunction((result) => {\r\n    expect(result).toBe('expected');\r\n    done(); // Must call done!\r\n  });\r\n});\r\n```\r\n\r\n**Important:** If you forget to call `done()`, the test will pass even if assertions fail, because Jest won't wait for them.\r\n\r\n---\r\n\r\n#### **Topic 2: Testing Promises (.then(), .catch())**\r\n**Explanation:**\r\nFor Promise-based code, return the Promise from the test. Jest will wait for it to resolve/reject.\r\n\r\n**Testing successful promises:**\r\n```javascript\r\ntest('promise resolves', () => {\r\n  return fetchData().then(data => {\r\n    expect(data).toBe('expected');\r\n  });\r\n});\r\n```\r\n\r\n**Testing rejected promises:**\r\n```javascript\r\ntest('promise rejects', () => {\r\n  return fetchData().catch(error => {\r\n    expect(error).toMatch('error');\r\n  });\r\n});\r\n```\r\n\r\n**Important:** Must return the promise! Otherwise Jest won't wait.\r\n\r\n---\r\n\r\n#### **Topic 3: Testing async/await**\r\n**Explanation:**\r\nThe cleanest way to test async code. Mark the test function as `async` and use `await`.\r\n\r\n**Syntax:**\r\n```javascript\r\ntest('async/await', async () => {\r\n  const data = await fetchData();\r\n  expect(data).toBe('expected');\r\n});\r\n```\r\n\r\n**Testing errors:**\r\n```javascript\r\ntest('async/await with error', async () => {\r\n  try {\r\n    await fetchData();\r\n  } catch (error) {\r\n    expect(error).toMatch('error');\r\n  }\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 4: .resolves and .rejects Matchers**\r\n**Explanation:**\r\nJest provides special matchers for testing promises without explicitly using `.then()` or `async/await`.\r\n\r\n**`.resolves`** - Tests successful promise resolution\r\n```javascript\r\ntest('promise resolves to value', () => {\r\n  return expect(fetchData()).resolves.toBe('expected');\r\n});\r\n\r\n// With async/await (cleaner)\r\ntest('promise resolves to value', async () => {\r\n  await expect(fetchData()).resolves.toBe('expected');\r\n});\r\n```\r\n\r\n**`.rejects`** - Tests promise rejection\r\n```javascript\r\ntest('promise rejects with error', () => {\r\n  return expect(fetchData()).rejects.toThrow('error');\r\n});\r\n\r\n// With async/await\r\ntest('promise rejects with error', async () => {\r\n  await expect(fetchData()).rejects.toThrow('error');\r\n});\r\n```\r\n\r\n**Important:** Must return the expect statement or use await!\r\n\r\n---\r\n\r\n#### **Topic 5: Handling Timeouts**\r\n**Explanation:**\r\nBy default, Jest waits 5 seconds for async tests. You can change this:\r\n\r\n**Per test:**\r\n```javascript\r\ntest('long running test', async () => {\r\n  // ...\r\n}, 10000); // 10 second timeout\r\n```\r\n\r\n**In beforeEach:**\r\n```javascript\r\nbeforeEach(() => {\r\n  jest.setTimeout(10000);\r\n});\r\n```\r\n\r\n**Globally in jest.config.js:**\r\n```javascript\r\nmodule.exports = {\r\n  testTimeout: 10000\r\n};\r\n```\r\n\r\n---\r\n\r\n#### **Topic 6: Testing Parallel Async Operations**\r\n**Explanation:**\r\nUse `Promise.all()` to test multiple async operations running in parallel.\r\n\r\n```javascript\r\ntest('multiple async operations', async () => {\r\n  const [result1, result2, result3] = await Promise.all([\r\n    fetchData1(),\r\n    fetchData2(),\r\n    fetchData3()\r\n  ]);\r\n  \r\n  expect(result1).toBe('data1');\r\n  expect(result2).toBe('data2');\r\n  expect(result3).toBe('data3');\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 7: Common Async Testing Mistakes**\r\n**Explanation:**\r\n\r\n**Mistake 1: Forgetting to return/await**\r\n```javascript\r\n// ❌ WRONG - Test passes even if promise rejects\r\ntest('wrong', () => {\r\n  fetchData().then(data => {\r\n    expect(data).toBe('expected');\r\n  });\r\n});\r\n\r\n// ✅ CORRECT\r\ntest('correct', () => {\r\n  return fetchData().then(data => {\r\n    expect(data).toBe('expected');\r\n  });\r\n});\r\n```\r\n\r\n**Mistake 2: Not using done() with callbacks**\r\n```javascript\r\n// ❌ WRONG - Test passes before callback runs\r\ntest('wrong', () => {\r\n  setTimeout(() => {\r\n    expect(true).toBe(false); // Never checked!\r\n  }, 100);\r\n});\r\n\r\n// ✅ CORRECT\r\ntest('correct', (done) => {\r\n  setTimeout(() => {\r\n    expect(true).toBe(true);\r\n    done();\r\n  }, 100);\r\n});\r\n```\r\n\r\n**Mistake 3: Not expecting assertion count**\r\n```javascript\r\n// ❌ WRONG - If callback never runs, test still passes\r\ntest('wrong', async () => {\r\n  await asyncOperation(() => {\r\n    expect(true).toBe(true);\r\n  });\r\n});\r\n\r\n// ✅ CORRECT\r\ntest('correct', async () => {\r\n  expect.assertions(1); // Ensures 1 assertion runs\r\n  await asyncOperation(() => {\r\n    expect(true).toBe(true);\r\n  });\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 8: Multiple Async Operations**\r\n**Explanation:**\r\n\r\n**Sequential operations:**\r\n```javascript\r\ntest('sequential async', async () => {\r\n  const data1 = await fetchData1();\r\n  const data2 = await fetchData2(data1);\r\n  const data3 = await fetchData3(data2);\r\n  expect(data3).toBe('final');\r\n});\r\n```\r\n\r\n**Parallel operations:**\r\n```javascript\r\ntest('parallel async', async () => {\r\n  const [data1, data2, data3] = await Promise.all([\r\n    fetchData1(),\r\n    fetchData2(),\r\n    fetchData3()\r\n  ]);\r\n  expect(data1).toBeDefined();\r\n  expect(data2).toBeDefined();\r\n  expect(data3).toBeDefined();\r\n});\r\n```"
};

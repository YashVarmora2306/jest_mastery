import { Step } from '../types';

export const step8: Step = {
  "id": "8",
  "title": "Testing with Timers - Controlling Time in Tests",
  "initialCode": "// ============================================\r\n// STEP 8: Testing with Timers\r\n// ============================================\r\n\r\n// Timer-based functions to test\r\n\r\nfunction delayedGreeting(name, delay, callback) {\r\n  setTimeout(() => {\r\n    callback(`Hello, ${name}!`);\r\n  }, delay);\r\n}\r\n\r\nfunction repeatMessage(message, interval, callback) {\r\n  return setInterval(() => {\r\n    callback(message);\r\n  }, interval);\r\n}\r\n\r\nfunction debounce(fn, delay) {\r\n  let timeoutId;\r\n  return function(...args) {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => fn.apply(this, args), delay);\r\n  };\r\n}\r\n\r\nfunction throttle(fn, limit) {\r\n  let inThrottle;\r\n  return function(...args) {\r\n    if (!inThrottle) {\r\n      fn.apply(this, args);\r\n      inThrottle = true;\r\n      setTimeout(() => inThrottle = false, limit);\r\n    }\r\n  };\r\n}\r\n\r\nfunction countdown(start, callback) {\r\n  let count = start;\r\n  const intervalId = setInterval(() => {\r\n    callback(count);\r\n    count--;\r\n    if (count < 0) {\r\n      clearInterval(intervalId);\r\n    }\r\n  }, 1000);\r\n  return intervalId;\r\n}\r\n\r\n// Polling function\r\nfunction startPolling(fetchFn, interval) {\r\n  const intervalId = setInterval(() => {\r\n    fetchFn();\r\n  }, interval);\r\n  \r\n  return () => clearInterval(intervalId);\r\n}\r\n\r\n// ============================================\r\n// EXAMPLE 1: Basic Fake Timers\r\n// ============================================\r\n\r\ntest('setTimeout with fake timers', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  setTimeout(callback, 1000);\r\n  \r\n  // Not called yet\r\n  expect(callback).not.toHaveBeenCalled();\r\n  \r\n  // Fast-forward time\r\n  jest.advanceTimersByTime(1000);\r\n  \r\n  // Now called\r\n  expect(callback).toHaveBeenCalled();\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\ntest('multiple timeouts with different delays', () => {\r\n  jest.useFakeTimers();\r\n  const callback1 = jest.fn();\r\n  const callback2 = jest.fn();\r\n  const callback3 = jest.fn();\r\n  \r\n  setTimeout(callback1, 100);\r\n  setTimeout(callback2, 500);\r\n  setTimeout(callback3, 1000);\r\n  \r\n  // After 100ms\r\n  jest.advanceTimersByTime(100);\r\n  expect(callback1).toHaveBeenCalled();\r\n  expect(callback2).not.toHaveBeenCalled();\r\n  expect(callback3).not.toHaveBeenCalled();\r\n  \r\n  // After 500ms total\r\n  jest.advanceTimersByTime(400);\r\n  expect(callback2).toHaveBeenCalled();\r\n  expect(callback3).not.toHaveBeenCalled();\r\n  \r\n  // After 1000ms total\r\n  jest.advanceTimersByTime(500);\r\n  expect(callback3).toHaveBeenCalled();\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 2: Testing setTimeout\r\n// ============================================\r\n\r\ntest('delayedGreeting calls callback after delay', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  delayedGreeting('Alice', 2000, callback);\r\n  \r\n  // Not called yet\r\n  expect(callback).not.toHaveBeenCalled();\r\n  \r\n  // Fast-forward 2000ms\r\n  jest.advanceTimersByTime(2000);\r\n  \r\n  // Now called with correct message\r\n  expect(callback).toHaveBeenCalledWith('Hello, Alice!');\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 3: Testing setInterval\r\n// ============================================\r\n\r\ntest('repeatMessage calls callback every interval', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  const intervalId = repeatMessage('tick', 1000, callback);\r\n  \r\n  // After 1 second\r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  expect(callback).toHaveBeenCalledWith('tick');\r\n  \r\n  // After 2 seconds\r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  \r\n  // After 5 seconds\r\n  jest.advanceTimersByTime(3000);\r\n  expect(callback).toHaveBeenCalledTimes(5);\r\n  \r\n  // Cleanup\r\n  clearInterval(intervalId);\r\n  jest.useRealTimers();\r\n});\r\n\r\ntest('countdown from 3 to 0', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  countdown(3, callback);\r\n  \r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledWith(3);\r\n  \r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledWith(2);\r\n  \r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledWith(1);\r\n  \r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledWith(0);\r\n  \r\n  expect(callback).toHaveBeenCalledTimes(4);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 4: runAllTimers vs runOnlyPendingTimers\r\n// ============================================\r\n\r\ntest('runAllTimers executes all timers including new ones', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  setTimeout(() => {\r\n    callback('first');\r\n    setTimeout(() => callback('second'), 1000);\r\n  }, 1000);\r\n  \r\n  jest.runAllTimers();\r\n  \r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  expect(callback).toHaveBeenNthCalledWith(1, 'first');\r\n  expect(callback).toHaveBeenNthCalledWith(2, 'second');\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\ntest('runOnlyPendingTimers executes only current timers', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  setTimeout(() => {\r\n    callback('first');\r\n    setTimeout(() => callback('second'), 1000);\r\n  }, 1000);\r\n  \r\n  jest.runOnlyPendingTimers();\r\n  \r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  expect(callback).toHaveBeenCalledWith('first');\r\n  // 'second' not called because it was scheduled during execution\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 5: advanceTimersToNextTimer\r\n// ============================================\r\n\r\ntest('advance to next timer', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  setTimeout(() => callback('100ms'), 100);\r\n  setTimeout(() => callback('500ms'), 500);\r\n  setTimeout(() => callback('1000ms'), 1000);\r\n  \r\n  // Execute first timer (100ms)\r\n  jest.advanceTimersToNextTimer();\r\n  expect(callback).toHaveBeenCalledWith('100ms');\r\n  \r\n  // Execute second timer (500ms)\r\n  jest.advanceTimersToNextTimer();\r\n  expect(callback).toHaveBeenCalledWith('500ms');\r\n  \r\n  // Execute third timer (1000ms)\r\n  jest.advanceTimersToNextTimer();\r\n  expect(callback).toHaveBeenCalledWith('1000ms');\r\n  \r\n  expect(callback).toHaveBeenCalledTimes(3);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 6: Testing Debounce\r\n// ============================================\r\n\r\ntest('debounce delays execution until pause', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  const debounced = debounce(callback, 300);\r\n  \r\n  // Rapid calls\r\n  debounced('call 1');\r\n  jest.advanceTimersByTime(100);\r\n  debounced('call 2');\r\n  jest.advanceTimersByTime(100);\r\n  debounced('call 3');\r\n  \r\n  // Still not called (keeps resetting)\r\n  expect(callback).not.toHaveBeenCalled();\r\n  \r\n  // Wait full delay\r\n  jest.advanceTimersByTime(300);\r\n  \r\n  // Only last call executed\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  expect(callback).toHaveBeenCalledWith('call 3');\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\ntest('debounce allows execution after pause', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  const debounced = debounce(callback, 200);\r\n  \r\n  debounced('first');\r\n  jest.advanceTimersByTime(200);\r\n  expect(callback).toHaveBeenCalledWith('first');\r\n  \r\n  // After a pause, new call\r\n  jest.advanceTimersByTime(500);\r\n  debounced('second');\r\n  jest.advanceTimersByTime(200);\r\n  expect(callback).toHaveBeenCalledWith('second');\r\n  \r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 7: Testing Throttle\r\n// ============================================\r\n\r\ntest('throttle limits execution rate', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  const throttled = throttle(callback, 1000);\r\n  \r\n  // First call executes immediately\r\n  throttled('call 1');\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  expect(callback).toHaveBeenCalledWith('call 1');\r\n  \r\n  // Subsequent calls within limit are ignored\r\n  jest.advanceTimersByTime(500);\r\n  throttled('call 2');\r\n  expect(callback).toHaveBeenCalledTimes(1); // Still 1\r\n  \r\n  // After limit, next call executes\r\n  jest.advanceTimersByTime(500);\r\n  throttled('call 3');\r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  expect(callback).toHaveBeenCalledWith('call 3');\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 8: jest.getTimerCount()\r\n// ============================================\r\n\r\ntest('getTimerCount shows pending timers', () => {\r\n  jest.useFakeTimers();\r\n  \r\n  expect(jest.getTimerCount()).toBe(0);\r\n  \r\n  setTimeout(() => {}, 1000);\r\n  expect(jest.getTimerCount()).toBe(1);\r\n  \r\n  setTimeout(() => {}, 2000);\r\n  setTimeout(() => {}, 3000);\r\n  expect(jest.getTimerCount()).toBe(3);\r\n  \r\n  jest.advanceTimersByTime(1000);\r\n  expect(jest.getTimerCount()).toBe(2); // First timer executed\r\n  \r\n  jest.runAllTimers();\r\n  expect(jest.getTimerCount()).toBe(0); // All timers executed\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\ntest('verifies timer cleanup', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  const cleanup = startPolling(callback, 1000);\r\n  expect(jest.getTimerCount()).toBe(1);\r\n  \r\n  cleanup();\r\n  expect(jest.getTimerCount()).toBe(0);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 9: Mocking Date.now()\r\n// ============================================\r\n\r\ntest('mock Date.now()', () => {\r\n  jest.useFakeTimers();\r\n  jest.setSystemTime(new Date('2024-01-01T00:00:00'));\r\n  \r\n  expect(new Date().getFullYear()).toBe(2024);\r\n  expect(new Date().getMonth()).toBe(0); // January\r\n  \r\n  // Advance time by 1 day\r\n  jest.advanceTimersByTime(24 * 60 * 60 * 1000);\r\n  expect(new Date().getDate()).toBe(2); // Jan 2nd\r\n  \r\n  jest.useRealTimers();\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 10: Real-World Timer Testing\r\n// ============================================\r\n\r\n// Auto-save feature\r\nclass AutoSave {\r\n  constructor(saveFn, delay = 2000) {\r\n    this.saveFn = saveFn;\r\n    this.delay = delay;\r\n    this.timeoutId = null;\r\n    this.pendingChanges = false;\r\n  }\r\n  \r\n  onChange(data) {\r\n    this.pendingChanges = true;\r\n    clearTimeout(this.timeoutId);\r\n    this.timeoutId = setTimeout(() => {\r\n      this.saveFn(data);\r\n      this.pendingChanges = false;\r\n    }, this.delay);\r\n  }\r\n  \r\n  forceSave(data) {\r\n    clearTimeout(this.timeoutId);\r\n    this.saveFn(data);\r\n    this.pendingChanges = false;\r\n  }\r\n  \r\n  hasPendingChanges() {\r\n    return this.pendingChanges;\r\n  }\r\n  \r\n  cleanup() {\r\n    clearTimeout(this.timeoutId);\r\n  }\r\n}\r\n\r\ndescribe('AutoSave', () => {\r\n  beforeEach(() => {\r\n    jest.useFakeTimers();\r\n  });\r\n  \r\n  afterEach(() => {\r\n    jest.useRealTimers();\r\n  });\r\n  \r\n  test('saves after delay', () => {\r\n    const saveFn = jest.fn();\r\n    const autoSave = new AutoSave(saveFn, 2000);\r\n    \r\n    autoSave.onChange('data');\r\n    expect(saveFn).not.toHaveBeenCalled();\r\n    expect(autoSave.hasPendingChanges()).toBe(true);\r\n    \r\n    jest.advanceTimersByTime(2000);\r\n    expect(saveFn).toHaveBeenCalledWith('data');\r\n    expect(autoSave.hasPendingChanges()).toBe(false);\r\n  });\r\n  \r\n  test('debounces multiple changes', () => {\r\n    const saveFn = jest.fn();\r\n    const autoSave = new AutoSave(saveFn, 2000);\r\n    \r\n    autoSave.onChange('v1');\r\n    jest.advanceTimersByTime(1000);\r\n    \r\n    autoSave.onChange('v2');\r\n    jest.advanceTimersByTime(1000);\r\n    \r\n    autoSave.onChange('v3');\r\n    jest.advanceTimersByTime(2000);\r\n    \r\n    // Only saved once with last version\r\n    expect(saveFn).toHaveBeenCalledTimes(1);\r\n    expect(saveFn).toHaveBeenCalledWith('v3');\r\n  });\r\n  \r\n  test('forceSave saves immediately', () => {\r\n    const saveFn = jest.fn();\r\n    const autoSave = new AutoSave(saveFn, 2000);\r\n    \r\n    autoSave.onChange('data');\r\n    autoSave.forceSave('data');\r\n    \r\n    expect(saveFn).toHaveBeenCalledWith('data');\r\n    expect(autoSave.hasPendingChanges()).toBe(false);\r\n    \r\n    // Timer should not trigger save again\r\n    jest.advanceTimersByTime(2000);\r\n    expect(saveFn).toHaveBeenCalledTimes(1);\r\n  });\r\n  \r\n  test('cleanup clears pending timers', () => {\r\n    const saveFn = jest.fn();\r\n    const autoSave = new AutoSave(saveFn, 2000);\r\n    \r\n    autoSave.onChange('data');\r\n    expect(jest.getTimerCount()).toBe(1);\r\n    \r\n    autoSave.cleanup();\r\n    expect(jest.getTimerCount()).toBe(0);\r\n    \r\n    jest.advanceTimersByTime(2000);\r\n    expect(saveFn).not.toHaveBeenCalled();\r\n  });\r\n});\n",
  "description": "## **Step 8: Testing with Timers**\r\n\r\n#### **Topic 1: jest.useFakeTimers() and jest.useRealTimers()**\r\n**Explanation:**\r\n\r\n**`jest.useFakeTimers()`** - Replaces native timer functions with Jest's mock timers\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nsetTimeout(() => {\r\n  console.log('This won't run automatically');\r\n}, 1000);\r\n\r\n// Time doesn't actually pass!\r\n```\r\n\r\n**`jest.useRealTimers()`** - Restores native timer functions\r\n```javascript\r\njest.useRealTimers();\r\n// Back to normal timers\r\n```\r\n\r\n**Why use fake timers?**\r\n- Tests run instantly (no waiting)\r\n- Full control over time\r\n- Deterministic tests\r\n- No race conditions\r\n\r\n**Common timers mocked:**\r\n- `setTimeout`\r\n- `setInterval`\r\n- `clearTimeout`\r\n- `clearInterval`\r\n- `Date.now()`\r\n\r\n---\r\n\r\n#### **Topic 2: Fast-forwarding Time with jest.advanceTimersByTime()**\r\n**Explanation:**\r\n\r\n**`.advanceTimersByTime(ms)`** - Advances all timers by specified milliseconds\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nconst callback = jest.fn();\r\nsetTimeout(callback, 1000);\r\n\r\n// Fast-forward 1000ms\r\njest.advanceTimersByTime(1000);\r\n\r\nexpect(callback).toHaveBeenCalled();\r\n```\r\n\r\n**Note:** Only pending timers are executed. New timers scheduled during execution won't run unless you advance time again.\r\n\r\n---\r\n\r\n#### **Topic 3: Testing setTimeout**\r\n**Explanation:**\r\n\r\n```javascript\r\nfunction delayedGreeting(callback) {\r\n  setTimeout(() => {\r\n    callback('Hello!');\r\n  }, 1000);\r\n}\r\n\r\ntest('calls callback after 1 second', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  delayedGreeting(callback);\r\n  \r\n  // Not called yet\r\n  expect(callback).not.toHaveBeenCalled();\r\n  \r\n  // Fast-forward 1000ms\r\n  jest.advanceTimersByTime(1000);\r\n  \r\n  // Now called\r\n  expect(callback).toHaveBeenCalledWith('Hello!');\r\n  \r\n  jest.useRealTimers();\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 4: Testing setInterval**\r\n**Explanation:**\r\n\r\n```javascript\r\nfunction repeatEverySecond(callback) {\r\n  setInterval(callback, 1000);\r\n}\r\n\r\ntest('calls callback every second', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  \r\n  repeatEverySecond(callback);\r\n  \r\n  // After 1 second - called once\r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  \r\n  // After 2 seconds total - called twice\r\n  jest.advanceTimersByTime(1000);\r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  \r\n  // After 5 seconds total - called 5 times\r\n  jest.advanceTimersByTime(3000);\r\n  expect(callback).toHaveBeenCalledTimes(5);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 5: jest.runAllTimers() and jest.runOnlyPendingTimers()**\r\n**Explanation:**\r\n\r\n**`.runAllTimers()`** - Executes ALL pending timers (including new ones scheduled during execution)\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nsetTimeout(() => {\r\n  console.log('First');\r\n  setTimeout(() => console.log('Second'), 1000);\r\n}, 1000);\r\n\r\njest.runAllTimers();\r\n// Runs: First, then Second (both timers execute)\r\n```\r\n\r\n**`.runOnlyPendingTimers()`** - Executes only currently pending timers (not new ones)\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nsetTimeout(() => {\r\n  console.log('First');\r\n  setTimeout(() => console.log('Second'), 1000);\r\n}, 1000);\r\n\r\njest.runOnlyPendingTimers();\r\n// Runs: First (but not Second)\r\n```\r\n\r\n**Warning:** `runAllTimers()` can cause infinite loops with `setInterval`!\r\n\r\n---\r\n\r\n#### **Topic 6: jest.advanceTimersToNextTimer()**\r\n**Explanation:**\r\n\r\n**`.advanceTimersToNextTimer()`** - Advances to the next timer (most useful for multiple timers with different delays)\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nsetTimeout(() => console.log('100ms'), 100);\r\nsetTimeout(() => console.log('500ms'), 500);\r\nsetTimeout(() => console.log('1000ms'), 1000);\r\n\r\njest.advanceTimersToNextTimer(); // Runs 100ms timer\r\njest.advanceTimersToNextTimer(); // Runs 500ms timer\r\njest.advanceTimersToNextTimer(); // Runs 1000ms timer\r\n```\r\n\r\n---\r\n\r\n#### **Topic 7: Testing Debounce Functions**\r\n**Explanation:**\r\n\r\n**Debounce** delays function execution until after a pause in calls.\r\n\r\n```javascript\r\nfunction debounce(fn, delay) {\r\n  let timeoutId;\r\n  return function(...args) {\r\n    clearTimeout(timeoutId);\r\n    timeoutId = setTimeout(() => fn(...args), delay);\r\n  };\r\n}\r\n\r\ntest('debounce delays execution', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  const debounced = debounce(callback, 1000);\r\n  \r\n  // Call multiple times quickly\r\n  debounced('first');\r\n  debounced('second');\r\n  debounced('third');\r\n  \r\n  // Nothing called yet\r\n  expect(callback).not.toHaveBeenCalled();\r\n  \r\n  // Fast-forward\r\n  jest.advanceTimersByTime(1000);\r\n  \r\n  // Only last call executed\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  expect(callback).toHaveBeenCalledWith('third');\r\n  \r\n  jest.useRealTimers();\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 8: Testing Throttle Functions**\r\n**Explanation:**\r\n\r\n**Throttle** ensures function executes at most once per time period.\r\n\r\n```javascript\r\nfunction throttle(fn, delay) {\r\n  let lastCall = 0;\r\n  return function(...args) {\r\n    const now = Date.now();\r\n    if (now - lastCall >= delay) {\r\n      lastCall = now;\r\n      fn(...args);\r\n    }\r\n  };\r\n}\r\n\r\ntest('throttle limits execution rate', () => {\r\n  jest.useFakeTimers();\r\n  const callback = jest.fn();\r\n  const throttled = throttle(callback, 1000);\r\n  \r\n  // First call executes\r\n  throttled('first');\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  \r\n  // Second call blocked (within 1000ms)\r\n  jest.advanceTimersByTime(500);\r\n  throttled('second');\r\n  expect(callback).toHaveBeenCalledTimes(1);\r\n  \r\n  // Third call executes (after 1000ms)\r\n  jest.advanceTimersByTime(500);\r\n  throttled('third');\r\n  expect(callback).toHaveBeenCalledTimes(2);\r\n  \r\n  jest.useRealTimers();\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 9: jest.getTimerCount()**\r\n**Explanation:**\r\n\r\n**`.getTimerCount()`** - Returns the number of pending timers\r\n```javascript\r\njest.useFakeTimers();\r\n\r\nsetTimeout(() => {}, 1000);\r\nsetTimeout(() => {}, 2000);\r\nsetInterval(() => {}, 1000);\r\n\r\nexpect(jest.getTimerCount()).toBe(3);\r\n\r\njest.runOnlyPendingTimers();\r\nexpect(jest.getTimerCount()).toBe(1); // Only setInterval remains\r\n```\r\n\r\n**Useful for:**\r\n- Verifying all timers cleaned up\r\n- Debugging timer issues\r\n- Checking for memory leaks\r\n\r\n---\r\n\r\n#### **Topic 10: Mocking Date.now()**\r\n**Explanation:**\r\n\r\n**Mock current time:**\r\n```javascript\r\njest.useFakeTimers();\r\njest.setSystemTime(new Date('2024-01-01'));\r\n\r\nexpect(Date.now()).toBe(new Date('2024-01-01').getTime());\r\n\r\n// Advance time\r\njest.advanceTimersByTime(1000);\r\nexpect(Date.now()).toBe(new Date('2024-01-01').getTime() + 1000);\r\n```\r\n\r\n---\r\n\r\n#### **Topic 11: Timer Cleanup and Best Practices**\r\n**Explanation:**\r\n\r\n**Best Practice 1: Always cleanup**\r\n```javascript\r\nafterEach(() => {\r\n  jest.useRealTimers();\r\n  jest.clearAllTimers();\r\n});\r\n```\r\n\r\n**Best Practice 2: Use in beforeEach for test isolation**\r\n```javascript\r\nbeforeEach(() => {\r\n  jest.useFakeTimers();\r\n});\r\n\r\nafterEach(() => {\r\n  jest.useRealTimers();\r\n});\r\n```\r\n\r\n**Best Practice 3: Clear timers in component cleanup**\r\n```javascript\r\ntest('clears timer on unmount', () => {\r\n  jest.useFakeTimers();\r\n  \r\n  const cleanup = startPolling();\r\n  expect(jest.getTimerCount()).toBe(1);\r\n  \r\n  cleanup(); // Should clear the interval\r\n  expect(jest.getTimerCount()).toBe(0);\r\n});\r\n```"
};

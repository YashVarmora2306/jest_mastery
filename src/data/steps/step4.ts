import { Step } from '../types';

export const step4: Step = {
  "id": "4",
  "title": "Setup and Teardown - Lifecycle Methods",
  "initialCode": "// ============================================\r\n// STEP 4: Setup and Teardown\r\n// ============================================\r\n\r\n// Database Mock Class\r\nclass Database {\r\n  constructor() {\r\n    this.connected = false;\r\n    this.data = [];\r\n  }\r\n\r\n  connect() {\r\n    this.connected = true;\r\n    console.log('Database connected');\r\n  }\r\n\r\n  disconnect() {\r\n    this.connected = false;\r\n    this.data = [];\r\n    console.log('Database disconnected');\r\n  }\r\n\r\n  insert(item) {\r\n    if (!this.connected) {\r\n      throw new Error('Not connected to database');\r\n    }\r\n    this.data.push(item);\r\n  }\r\n\r\n  findAll() {\r\n    if (!this.connected) {\r\n      throw new Error('Not connected to database');\r\n    }\r\n    return this.data;\r\n  }\r\n\r\n  clear() {\r\n    this.data = [];\r\n  }\r\n}\r\n\r\n// User Service Class\r\nclass UserService {\r\n  constructor() {\r\n    this.users = [];\r\n  }\r\n\r\n  addUser(user) {\r\n    if (!user.name || !user.email) {\r\n      throw new Error('Name and email required');\r\n    }\r\n    this.users.push({ ...user, id: this.users.length + 1 });\r\n    return this.users[this.users.length - 1];\r\n  }\r\n\r\n  getUsers() {\r\n    return this.users;\r\n  }\r\n\r\n  clear() {\r\n    this.users = [];\r\n  }\r\n}\r\n\r\n// ============================================\r\n// EXAMPLE 1: beforeEach() and afterEach()\r\n// ============================================\r\n\r\ndescribe('UserService - beforeEach/afterEach', () => {\r\n  let userService;\r\n\r\n  // Runs before each test\r\n  beforeEach(() => {\r\n    userService = new UserService();\r\n    console.log('beforeEach: Created fresh UserService');\r\n  });\r\n\r\n  // Runs after each test\r\n  afterEach(() => {\r\n    userService.clear();\r\n    console.log('afterEach: Cleaned up UserService');\r\n  });\r\n\r\n  test('adds user successfully', () => {\r\n    const user = userService.addUser({ name: 'John', email: 'john@example.com' });\r\n    expect(user.name).toBe('John');\r\n    expect(userService.getUsers()).toHaveLength(1);\r\n  });\r\n\r\n  test('starts with empty users (test isolation)', () => {\r\n    // Even though previous test added a user, this test starts fresh\r\n    expect(userService.getUsers()).toHaveLength(0);\r\n  });\r\n\r\n  test('adds multiple users', () => {\r\n    userService.addUser({ name: 'John', email: 'john@example.com' });\r\n    userService.addUser({ name: 'Jane', email: 'jane@example.com' });\r\n    expect(userService.getUsers()).toHaveLength(2);\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 2: beforeAll() and afterAll()\r\n// ============================================\r\n\r\ndescribe('Database - beforeAll/afterAll', () => {\r\n  let db;\r\n\r\n  // Runs once before all tests\r\n  beforeAll(() => {\r\n    db = new Database();\r\n    db.connect();\r\n    console.log('beforeAll: Database connected');\r\n  });\r\n\r\n  // Runs once after all tests\r\n  afterAll(() => {\r\n    db.disconnect();\r\n    console.log('afterAll: Database disconnected');\r\n  });\r\n\r\n  // Clean data between tests, but keep connection\r\n  beforeEach(() => {\r\n    db.clear();\r\n  });\r\n\r\n  test('inserts data into database', () => {\r\n    db.insert({ name: 'John' });\r\n    expect(db.findAll()).toHaveLength(1);\r\n  });\r\n\r\n  test('database is still connected', () => {\r\n    expect(db.connected).toBe(true);\r\n  });\r\n\r\n  test('starts with clean data', () => {\r\n    expect(db.findAll()).toHaveLength(0);\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 3: Scoping and Nesting\r\n// ============================================\r\n\r\ndescribe('Outer Scope', () => {\r\n  let outerValue;\r\n\r\n  beforeAll(() => {\r\n    console.log('1. Outer beforeAll');\r\n  });\r\n\r\n  beforeEach(() => {\r\n    outerValue = 'outer';\r\n    console.log('2. Outer beforeEach');\r\n  });\r\n\r\n  afterEach(() => {\r\n    console.log('4. Outer afterEach');\r\n  });\r\n\r\n  afterAll(() => {\r\n    console.log('5. Outer afterAll');\r\n  });\r\n\r\n  test('outer test', () => {\r\n    console.log('3. Outer test');\r\n    expect(outerValue).toBe('outer');\r\n  });\r\n\r\n  describe('Inner Scope', () => {\r\n    let innerValue;\r\n\r\n    beforeEach(() => {\r\n      innerValue = 'inner';\r\n      console.log('3. Inner beforeEach (after outer beforeEach)');\r\n    });\r\n\r\n    afterEach(() => {\r\n      console.log('3.5. Inner afterEach (before outer afterEach)');\r\n    });\r\n\r\n    test('inner test has access to both', () => {\r\n      console.log('3. Inner test');\r\n      expect(outerValue).toBe('outer'); // From outer beforeEach\r\n      expect(innerValue).toBe('inner'); // From inner beforeEach\r\n    });\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 4: Test Isolation Example\r\n// ============================================\r\n\r\ndescribe('Counter - Good Isolation', () => {\r\n  let counter;\r\n\r\n  beforeEach(() => {\r\n    counter = 0; // Fresh counter for each test\r\n  });\r\n\r\n  test('increments from 0', () => {\r\n    counter++;\r\n    expect(counter).toBe(1);\r\n  });\r\n\r\n  test('also increments from 0 (isolated)', () => {\r\n    counter++;\r\n    expect(counter).toBe(1); // Starts fresh, not 2!\r\n  });\r\n\r\n  test('decrements from 0', () => {\r\n    counter--;\r\n    expect(counter).toBe(-1);\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 5: Execution Order Demonstration\r\n// ============================================\r\n\r\ndescribe('Execution Order', () => {\r\n  const executionLog = [];\r\n\r\n  beforeAll(() => {\r\n    executionLog.push('beforeAll');\r\n  });\r\n\r\n  beforeEach(() => {\r\n    executionLog.push('beforeEach');\r\n  });\r\n\r\n  afterEach(() => {\r\n    executionLog.push('afterEach');\r\n  });\r\n\r\n  afterAll(() => {\r\n    executionLog.push('afterAll');\r\n  });\r\n\r\n  test('first test', () => {\r\n    executionLog.push('test 1');\r\n    expect(executionLog).toEqual(['beforeAll', 'beforeEach', 'test 1']);\r\n  });\r\n\r\n  test('second test', () => {\r\n    executionLog.push('test 2');\r\n    // beforeEach runs again before this test\r\n    expect(executionLog).toContain('test 2');\r\n  });\r\n\r\n  test('verify execution order after all tests', () => {\r\n    executionLog.push('test 3');\r\n    // This won't be complete until afterAll runs\r\n    expect(executionLog).toContain('test 3');\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 6: Real-World Pattern\r\n// ============================================\r\n\r\ndescribe('Shopping Cart - Real World Pattern', () => {\r\n  let cart;\r\n  let db;\r\n\r\n  // Expensive setup - do once\r\n  beforeAll(() => {\r\n    db = new Database();\r\n    db.connect();\r\n  });\r\n\r\n  // Cheap setup - do before each test\r\n  beforeEach(() => {\r\n    cart = {\r\n      items: [],\r\n      addItem(item) {\r\n        this.items.push(item);\r\n      },\r\n      getTotal() {\r\n        return this.items.reduce((sum, item) => sum + item.price, 0);\r\n      },\r\n      clear() {\r\n        this.items = [];\r\n      }\r\n    };\r\n    db.clear(); // Clean database data\r\n  });\r\n\r\n  // Cleanup after each test\r\n  afterEach(() => {\r\n    cart.clear();\r\n  });\r\n\r\n  // Expensive cleanup - do once\r\n  afterAll(() => {\r\n    db.disconnect();\r\n  });\r\n\r\n  test('adds item to cart', () => {\r\n    cart.addItem({ name: 'Book', price: 10 });\r\n    expect(cart.items).toHaveLength(1);\r\n  });\r\n\r\n  test('calculates total', () => {\r\n    cart.addItem({ name: 'Book', price: 10 });\r\n    cart.addItem({ name: 'Pen', price: 5 });\r\n    expect(cart.getTotal()).toBe(15);\r\n  });\r\n\r\n  test('cart is empty at start (isolation)', () => {\r\n    expect(cart.items).toHaveLength(0);\r\n  });\r\n});\r\n\r\n// ============================================\r\n// EXAMPLE 7: When to Use Each Method\r\n// ============================================\r\n\r\ndescribe('Best Practices Guide', () => {\r\n  // Use beforeAll for expensive one-time setup\r\n  beforeAll(() => {\r\n    // - Connect to database\r\n    // - Start server\r\n    // - Load config files\r\n    // - Create test fixtures\r\n  });\r\n\r\n  // Use beforeEach for fresh test data\r\n  beforeEach(() => {\r\n    // - Create new instances\r\n    // - Reset counters\r\n    // - Clear mocks\r\n    // - Prepare test data\r\n  });\r\n\r\n  // Use afterEach for test cleanup\r\n  afterEach(() => {\r\n    // - Clear test data\r\n    // - Reset mocks\r\n    // - Close file handles\r\n  });\r\n\r\n  // Use afterAll for expensive cleanup\r\n  afterAll(() => {\r\n    // - Disconnect from database\r\n    // - Stop server\r\n    // - Delete test files\r\n  });\r\n\r\n  test('example test', () => {\r\n    expect(true).toBe(true);\r\n  });\r\n});\n",
  "description": "## **Step 4: Setup and Teardown**\r\n\r\n#### **Topic 1: beforeEach() and afterEach()**\r\n**Explanation:**\r\n\r\n**`beforeEach()`** - Runs before each test in the describe block\r\n```javascript\r\nbeforeEach(() => {\r\n  // Setup code that runs before each test\r\n});\r\n```\r\n\r\n**`afterEach()`** - Runs after each test in the describe block\r\n```javascript\r\nafterEach(() => {\r\n  // Cleanup code that runs after each test\r\n});\r\n```\r\n\r\n**Use cases:**\r\n- Creating fresh instances for each test\r\n- Resetting mock functions\r\n- Cleaning up resources\r\n- Ensuring test isolation\r\n\r\n---\r\n\r\n#### **Topic 2: beforeAll() and afterAll()**\r\n**Explanation:**\r\n\r\n**`beforeAll()`** - Runs once before all tests in the describe block\r\n```javascript\r\nbeforeAll(() => {\r\n  // One-time setup before all tests\r\n});\r\n```\r\n\r\n**`afterAll()`** - Runs once after all tests in the describe block\r\n```javascript\r\nafterAll(() => {\r\n  // One-time cleanup after all tests\r\n});\r\n```\r\n\r\n**Use cases:**\r\n- Setting up test database\r\n- Establishing connections\r\n- Creating expensive resources\r\n- Final cleanup\r\n\r\n---\r\n\r\n#### **Topic 3: Scoping of Setup/Teardown**\r\n**Explanation:**\r\nSetup and teardown functions are scoped to their describe block. Inner describe blocks inherit and run outer setup/teardown functions.\r\n\r\n```javascript\r\ndescribe('Outer', () => {\r\n  beforeEach(() => console.log('Outer beforeEach'));\r\n  \r\n  test('outer test', () => {\r\n    // Runs: Outer beforeEach → test\r\n  });\r\n  \r\n  describe('Inner', () => {\r\n    beforeEach(() => console.log('Inner beforeEach'));\r\n    \r\n    test('inner test', () => {\r\n      // Runs: Outer beforeEach → Inner beforeEach → test\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 4: When to Use Each Lifecycle Method**\r\n**Explanation:**\r\n\r\n**beforeEach/afterEach:**\r\n- Creating fresh test data for each test\r\n- Resetting mocks between tests\r\n- Ensuring test independence\r\n- Most common lifecycle hooks\r\n\r\n**beforeAll/afterAll:**\r\n- Database connections (expensive to create)\r\n- Server startup/shutdown\r\n- Loading configuration files\r\n- One-time resource allocation\r\n\r\n**Rule of thumb:** Prefer `beforeEach` for test isolation unless setup is too expensive.\r\n\r\n---\r\n\r\n#### **Topic 5: Nested Setup/Teardown**\r\n**Explanation:**\r\nWhen describe blocks are nested, lifecycle hooks run in a specific order:\r\n\r\n```javascript\r\ndescribe('Parent', () => {\r\n  beforeAll(() => console.log('1. Parent beforeAll'));\r\n  beforeEach(() => console.log('3. Parent beforeEach'));\r\n  afterEach(() => console.log('6. Parent afterEach'));\r\n  afterAll(() => console.log('8. Parent afterAll'));\r\n  \r\n  describe('Child', () => {\r\n    beforeAll(() => console.log('2. Child beforeAll'));\r\n    beforeEach(() => console.log('4. Child beforeEach'));\r\n    afterEach(() => console.log('5. Child afterEach'));\r\n    afterAll(() => console.log('7. Child afterAll'));\r\n    \r\n    test('test', () => console.log('5. Test runs'));\r\n  });\r\n});\r\n```\r\n\r\n**Execution order:**\r\n1. Parent beforeAll\r\n2. Child beforeAll\r\n3. Parent beforeEach\r\n4. Child beforeEach\r\n5. Test runs\r\n6. Child afterEach\r\n7. Parent afterEach\r\n8. Child afterAll\r\n9. Parent afterAll\r\n\r\n---\r\n\r\n#### **Topic 6: Test Isolation Principles**\r\n**Explanation:**\r\n\r\n**Test isolation** means each test should:\r\n1. Not depend on other tests\r\n2. Not affect other tests\r\n3. Be able to run in any order\r\n4. Be able to run alone\r\n\r\n**Achieving isolation:**\r\n```javascript\r\ndescribe('Counter', () => {\r\n  let counter;\r\n  \r\n  beforeEach(() => {\r\n    counter = 0; // Fresh state for each test\r\n  });\r\n  \r\n  test('increments', () => {\r\n    counter++;\r\n    expect(counter).toBe(1);\r\n  });\r\n  \r\n  test('decrements', () => {\r\n    counter--;\r\n    expect(counter).toBe(-1); // Starts fresh at 0\r\n  });\r\n});\r\n```\r\n\r\n**Without isolation (BAD):**\r\n```javascript\r\nlet counter = 0; // Shared across all tests\r\n\r\ntest('increments', () => {\r\n  counter++; // counter = 1\r\n});\r\n\r\ntest('decrements', () => {\r\n  counter--; // counter = 0 (depends on previous test!)\r\n});\r\n```\r\n\r\n---\r\n\r\n#### **Topic 7: Execution Order of Lifecycle Methods**\r\n**Explanation:**\r\n\r\n**Order for a single test:**\r\n1. beforeAll\r\n2. beforeEach\r\n3. test\r\n4. afterEach\r\n5. afterAll (after all tests in describe)\r\n\r\n**Order for multiple tests:**\r\n```\r\nbeforeAll\r\n  beforeEach\r\n    test 1\r\n  afterEach\r\n  beforeEach\r\n    test 2\r\n  afterEach\r\n  beforeEach\r\n    test 3\r\n  afterEach\r\nafterAll\r\n```"
};
